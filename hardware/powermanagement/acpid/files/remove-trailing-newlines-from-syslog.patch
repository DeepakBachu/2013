Index: acpid-2.0.8/acpid.c
===================================================================
--- acpid-2.0.8.orig/acpid.c
+++ acpid-2.0.8/acpid.c
@@ -116,7 +116,7 @@ main(int argc, char **argv)
 		exit(EXIT_FAILURE);
 	}
 	
-	acpid_log(LOG_INFO, "starting up with %s\n",
+	acpid_log(LOG_INFO, "starting up with %s",
 		netlink ? "netlink and the input layer" : "proc fs");
 
 	/* trap key signals */
@@ -136,7 +136,7 @@ main(int argc, char **argv)
 		exit(EXIT_FAILURE);
 	}
 
-	acpid_log(LOG_INFO, "waiting for events: event logging is %s\n",
+	acpid_log(LOG_INFO, "waiting for events: event logging is %s",
 	    logevents ? "on" : "off");
 
 	/* main loop */
@@ -156,7 +156,7 @@ main(int argc, char **argv)
 		if (nready < 0  &&  errno == EINTR) {
 			continue;
 		} else if (nready < 0) {
-			acpid_log(LOG_ERR, "select(): %s\n", strerror(errno));
+			acpid_log(LOG_ERR, "select(): %s", strerror(errno));
 			continue;
 		}
 
@@ -335,7 +335,7 @@ daemonize(void)
 	/* fork off the parent process */
 	pid = fork();
 	if (pid < 0) {
-		acpid_log(LOG_ERR, "fork: %s\n", strerror(errno));
+		acpid_log(LOG_ERR, "fork: %s", strerror(errno));
 		return -1;
 	}
 	/* if we got a good PID, then we can exit the parent process */
@@ -353,14 +353,14 @@ daemonize(void)
 	/* detach the process from the parent (normally a shell) */
 	sid = setsid();
 	if (sid < 0) {
-		acpid_log(LOG_ERR, "setsid: %s\n", strerror(errno));
+		acpid_log(LOG_ERR, "setsid: %s", strerror(errno));
 		return -1;
 	}
 
     /* Change the current working directory.  This prevents the current
        directory from being locked; hence not being able to remove it. */
 	if (chdir("/") < 0) {
-		acpid_log(LOG_ERR, "chdir(\"/\"): %s\n", strerror(errno));
+		acpid_log(LOG_ERR, "chdir(\"/\"): %s", strerror(errno));
 		return -1;
 	}
 
@@ -388,21 +388,21 @@ std2null(void)
 	/* open /dev/null */
 	nullfd = open("/dev/null", O_RDWR);
 	if (nullfd < 0) {
-		acpid_log(LOG_ERR, "can't open /dev/null: %s\n", strerror(errno));
+		acpid_log(LOG_ERR, "can't open /dev/null: %s", strerror(errno));
 		return -1;
 	}
 
 	/* set up stdin, stdout, stderr to /dev/null */
 	if (dup2(nullfd, STDIN_FILENO) != STDIN_FILENO) {
-		acpid_log(LOG_ERR, "dup2() stdin: %s\n", strerror(errno));
+		acpid_log(LOG_ERR, "dup2() stdin: %s", strerror(errno));
 		return -1;
 	}
 	if (!acpid_debug && dup2(nullfd, STDOUT_FILENO) != STDOUT_FILENO) {
-		acpid_log(LOG_ERR, "dup2() stdout: %s\n", strerror(errno));
+		acpid_log(LOG_ERR, "dup2() stdout: %s", strerror(errno));
 		return -1;
 	}
 	if (!acpid_debug && dup2(nullfd, STDERR_FILENO) != STDERR_FILENO) {
-		acpid_log(LOG_ERR, "dup2() stderr: %s\n", strerror(errno));
+		acpid_log(LOG_ERR, "dup2() stderr: %s", strerror(errno));
 		return -1;
 	}
 
@@ -436,7 +436,7 @@ create_pidfile(void)
 	}
 
 	/* something went wrong */
-	acpid_log(LOG_ERR, "can't create pidfile %s: %s\n",
+	acpid_log(LOG_ERR, "can't create pidfile %s: %s",
 		    pidfile, strerror(errno));
 	return -1;
 }
@@ -445,7 +445,7 @@ void
 clean_exit_with_status(int status)
 {
 	acpid_cleanup_rules(1);
-	acpid_log(LOG_NOTICE, "exiting\n");
+	acpid_log(LOG_NOTICE, "exiting");
 	unlink(pidfile);
 	exit(status);
 }
@@ -459,7 +459,7 @@ clean_exit(int sig __attribute__((unused
 static void
 reload_conf(int sig __attribute__((unused)))
 {
-	acpid_log(LOG_NOTICE, "reloading configuration\n");
+	acpid_log(LOG_NOTICE, "reloading configuration");
 	acpid_cleanup_rules(0);
 	acpid_read_conf(confdir);
 }
Index: acpid-2.0.8/connection_list.c
===================================================================
--- acpid-2.0.8.orig/connection_list.c
+++ acpid-2.0.8/connection_list.c
@@ -54,7 +54,7 @@ add_connection(struct connection *p)
 	if (nconnections < 0)
 		return;
 	if (nconnections >= MAX_CONNECTIONS) {
-		acpid_log(LOG_ERR, "Too many connections.\n");
+		acpid_log(LOG_ERR, "Too many connections.");
 		/* ??? This routine should return -1 in this situation so that */
 		/*   callers can clean up any open fds and whatnot.  */
 		return;
Index: acpid-2.0.8/event.c
===================================================================
--- acpid-2.0.8.orig/event.c
+++ acpid-2.0.8/event.c
@@ -100,7 +100,7 @@ acpid_read_conf(const char *confdir)
 
 	dir = opendir(confdir);
 	if (!dir) {
-		acpid_log(LOG_ERR, "opendir(%s): %s\n",
+		acpid_log(LOG_ERR, "opendir(%s): %s",
 			confdir, strerror(errno));
 		unlock_rules();
 		return -1;
@@ -109,7 +109,7 @@ acpid_read_conf(const char *confdir)
 	/* Compile the regular expression.  This is based on run-parts(8). */
 	rc = regcomp(&preg, "^[a-zA-Z0-9_-]+$", RULE_REGEX_FLAGS);
 	if (rc) {
-		acpid_log(LOG_ERR, "regcomp(): %d\n", rc);
+		acpid_log(LOG_ERR, "regcomp(): %d", rc);
 		unlock_rules();
 		return -1;
 	}
@@ -132,7 +132,7 @@ acpid_read_conf(const char *confdir)
 		if (regexec(&preg, dirent->d_name, 0, NULL, 0) != 0) {
 			if(strcmp(dirent->d_name, ".") != 0 &&
 			   strcmp(dirent->d_name, "..") != 0) {
-				acpid_log(LOG_INFO, "skipping conf file %s/%s\n", 
+				acpid_log(LOG_INFO, "skipping conf file %s/%s", 
 				confdir, dirent->d_name);
 			}
 			continue;
@@ -144,7 +144,7 @@ acpid_read_conf(const char *confdir)
 
 		file = malloc(len);
 		if (!file) {
-			acpid_log(LOG_ERR, "malloc(): %s\n", strerror(errno));
+			acpid_log(LOG_ERR, "malloc(): %s", strerror(errno));
 			unlock_rules();
 			return -1;
 		}
@@ -152,13 +152,13 @@ acpid_read_conf(const char *confdir)
 
 		/* allow only regular files and symlinks to files */
 		if (stat(file, &stat_buf) != 0) {
-			acpid_log(LOG_ERR, "stat(%s): %s\n", file,
+			acpid_log(LOG_ERR, "stat(%s): %s", file,
 				strerror(errno));
 			free(file);
 			continue; /* keep trying the rest of the files */
 		}
 		if (!S_ISREG(stat_buf.st_mode)) {
-			acpid_log(LOG_INFO, "skipping non-file %s\n", file);
+			acpid_log(LOG_INFO, "skipping non-file %s", file);
 			free(file);
 			continue; /* skip non-regular files */
 		}
@@ -173,7 +173,7 @@ acpid_read_conf(const char *confdir)
 	closedir(dir);
 	unlock_rules();
 
-	acpid_log(LOG_INFO, "%d rule%s loaded\n",
+	acpid_log(LOG_INFO, "%d rule%s loaded",
 	    nrules, (nrules == 1)?"":"s");
 
 	return 0;
@@ -191,7 +191,7 @@ acpid_cleanup_rules(int do_detach)
 	lock_rules();
 
 	if (acpid_debug >= 3) {
-		acpid_log(LOG_DEBUG, "cleaning up rules\n");
+		acpid_log(LOG_DEBUG, "cleaning up rules");
 	}
 
 	if (do_detach) {
@@ -228,11 +228,11 @@ parse_file(const char *file)
 	int line = 0;
 	struct rule *r;
 
-	acpid_log(LOG_DEBUG, "parsing conf file %s\n", file);
+	acpid_log(LOG_DEBUG, "parsing conf file %s", file);
 
 	fp = fopen(file, "r");
 	if (!fp) {
-		acpid_log(LOG_ERR, "fopen(%s): %s\n", file, strerror(errno));
+		acpid_log(LOG_ERR, "fopen(%s): %s", file, strerror(errno));
 		return NULL;
 	}
 
@@ -245,7 +245,7 @@ parse_file(const char *file)
 	r->type = RULE_CMD;
 	r->origin = strdup(file);
 	if (!r->origin) {
-		acpid_log(LOG_ERR, "strdup(): %s\n", strerror(errno));
+		acpid_log(LOG_ERR, "strdup(): %s", strerror(errno));
 		free_rule(r);
 		fclose(fp);
 		return NULL;
@@ -278,12 +278,12 @@ parse_file(const char *file)
 		/* quick parse */
 		n = sscanf(p, "%63[^=\n]=%255[^\n]", key, val);
 		if (n != 2) {
-			acpid_log(LOG_WARNING, "can't parse %s at line %d\n",
+			acpid_log(LOG_WARNING, "can't parse %s at line %d",
 			    file, line);
 			continue;
 		}
 		if (acpid_debug >= 3) {
-			acpid_log(LOG_DEBUG, "    key=\"%s\" val=\"%s\"\n",
+			acpid_log(LOG_DEBUG, "    key=\"%s\" val=\"%s\"",
 			    key, val);
 		}
 		/* handle the parsed line */
@@ -291,7 +291,7 @@ parse_file(const char *file)
 			int rv;
 			r->event = malloc(sizeof(regex_t));
 			if (!r->event) {
-				acpid_log(LOG_ERR, "malloc(): %s\n",
+				acpid_log(LOG_ERR, "malloc(): %s",
 					strerror(errno));
 				free_rule(r);
 				fclose(fp);
@@ -301,14 +301,14 @@ parse_file(const char *file)
 			if (rv) {
 				char rbuf[128];
 				regerror(rv, r->event, rbuf, sizeof(rbuf));
-				acpid_log(LOG_ERR, "regcomp(): %s\n", rbuf);
+				acpid_log(LOG_ERR, "regcomp(): %s", rbuf);
 				free_rule(r);
 				fclose(fp);
 				return NULL;
 			}
 		} else if (!strcasecmp(key, "action")) {
 			if (check_escapes(val) < 0) {
-				acpid_log(LOG_ERR, "can't load file %s\n",
+				acpid_log(LOG_ERR, "can't load file %s",
 				    file);
 				free_rule(r);
 				fclose(fp);
@@ -316,7 +316,7 @@ parse_file(const char *file)
 			}
 			r->action.cmd = strdup(val);
 			if (!r->action.cmd) {
-				acpid_log(LOG_ERR, "strdup(): %s\n",
+				acpid_log(LOG_ERR, "strdup(): %s",
 					strerror(errno));
 				free_rule(r);
 				fclose(fp);
@@ -324,13 +324,13 @@ parse_file(const char *file)
 			}
 		} else {
 			acpid_log(LOG_WARNING,
-			    "unknown option '%s' in %s at line %d\n",
+			    "unknown option '%s' in %s at line %d",
 			    key, file, line);
 			continue;
 		}
 	}
 	if (!r->event || !r->action.cmd) {
-		acpid_log(LOG_INFO, "skipping incomplete file %s\n", file);
+		acpid_log(LOG_INFO, "skipping incomplete file %s", file);
 		free_rule(r);
 		fclose(fp);
 		return NULL;
@@ -346,7 +346,7 @@ acpid_add_client(int clifd, const char *
 	struct rule *r;
 	int nrules = 0;
 
-	acpid_log(LOG_NOTICE, "client connected from %s\n", origin);
+	acpid_log(LOG_NOTICE, "client connected from %s", origin);
 
 	r = parse_client(clifd);
 	if (r) {
@@ -355,7 +355,7 @@ acpid_add_client(int clifd, const char *
 		nrules++;
 	}
 
-	acpid_log(LOG_INFO, "%d client rule%s loaded\n",
+	acpid_log(LOG_INFO, "%d client rule%s loaded",
 	    nrules, (nrules == 1)?"":"s");
 
 	return 0;
@@ -376,7 +376,7 @@ parse_client(int client)
 	r->action.fd = client;
 	r->event = malloc(sizeof(regex_t));
 	if (!r->event) {
-		acpid_log(LOG_ERR, "malloc(): %s\n", strerror(errno));
+		acpid_log(LOG_ERR, "malloc(): %s", strerror(errno));
 		free_rule(r);
 		return NULL;
 	}
@@ -384,7 +384,7 @@ parse_client(int client)
 	if (rv) {
 		char buf[128];
 		regerror(rv, r->event, buf, sizeof(buf));
-		acpid_log(LOG_ERR, "regcomp(): %s\n", buf);
+		acpid_log(LOG_ERR, "regcomp(): %s", buf);
 		free_rule(r);
 		return NULL;
 	}
@@ -434,7 +434,7 @@ new_rule(void)
 
 	r = malloc(sizeof(*r));
 	if (!r) {
-		acpid_log(LOG_ERR, "malloc(): %s\n", strerror(errno));
+		acpid_log(LOG_ERR, "malloc(): %s", strerror(errno));
 		return NULL;
 	}
 
@@ -480,7 +480,7 @@ client_is_dead(int fd)
 	r = poll(&pfd, 1, 0);
 
 	if (r < 0) {
-		acpid_log(LOG_ERR, "poll(): %s\n", strerror(errno));
+		acpid_log(LOG_ERR, "poll(): %s", strerror(errno));
 		return 0;
 	}
 
@@ -502,7 +502,7 @@ acpid_close_dead_clients(void)
 			struct ucred cred;
 			/* closed */
 			acpid_log(LOG_NOTICE,
-			    "client %s has disconnected\n", p->origin);
+			    "client %s has disconnected", p->origin);
 			delist_rule(&client_list, p);
 			ud_get_peercred(p->action.fd, &cred);
 			if (cred.uid != 0) {
@@ -542,7 +542,7 @@ acpid_handle_event(const char *event)
 				/* a match! */
 				if (logevents) {
 					acpid_log(LOG_INFO,
-					    "rule from %s matched\n",
+					    "rule from %s matched",
 					    p->origin);
 				}
 				nrules++;
@@ -552,13 +552,13 @@ acpid_handle_event(const char *event)
 					do_client_rule(p, event);
 				} else {
 					acpid_log(LOG_WARNING,
-					    "unknown rule type: %d\n",
+					    "unknown rule type: %d",
 					    p->type);
 				}
 			} else {
 				if (acpid_debug >= 3 && logevents) {
 					acpid_log(LOG_INFO,
-					    "rule from %s did not match\n",
+					    "rule from %s did not match",
 					    p->origin);
 				}
 			}
@@ -569,7 +569,7 @@ acpid_handle_event(const char *event)
 	unlock_rules();
 
 	if (logevents) {
-		acpid_log(LOG_INFO, "%d total rule%s matched\n",
+		acpid_log(LOG_INFO, "%d total rule%s matched",
 			nrules, (nrules == 1)?"":"s");
 	}
 
@@ -595,7 +595,7 @@ static void
 lock_rules(void)
 {
 	if (acpid_debug >= 4) {
-		acpid_log(LOG_DEBUG, "blocking signals for rule lock\n");
+		acpid_log(LOG_DEBUG, "blocking signals for rule lock");
 	}
 	sigprocmask(SIG_BLOCK, signals_handled(), NULL);
 }
@@ -604,7 +604,7 @@ static void
 unlock_rules(void)
 {
 	if (acpid_debug >= 4) {
-		acpid_log(LOG_DEBUG, "unblocking signals for rule lock\n");
+		acpid_log(LOG_DEBUG, "unblocking signals for rule lock");
 	}
 	sigprocmask(SIG_UNBLOCK, signals_handled(), NULL);
 }
@@ -623,14 +623,14 @@ do_cmd_rule(struct rule *rule, const cha
 	pid = fork();
 	switch (pid) {
 	case -1:
-		acpid_log(LOG_ERR, "fork(): %s\n", strerror(errno));
+		acpid_log(LOG_ERR, "fork(): %s", strerror(errno));
 		return -1;
 	case 0: /* child */
 		/* parse the commandline, doing any substitutions needed */
 		action = parse_cmd(rule->action.cmd, event);
 		if (logevents) {
 			acpid_log(LOG_INFO,
-			    "executing action \"%s\"\n", action);
+			    "executing action \"%s\"", action);
 		}
 
 		/* reset signals */
@@ -646,7 +646,7 @@ do_cmd_rule(struct rule *rule, const cha
 		}
 		execl("/bin/sh", "/bin/sh", "-c", action, NULL);
 		/* should not get here */
-		acpid_log(LOG_ERR, "execl(): %s\n", strerror(errno));
+		acpid_log(LOG_ERR, "execl(): %s", strerror(errno));
 		exit(EXIT_FAILURE);
 	}
 
@@ -658,13 +658,13 @@ do_cmd_rule(struct rule *rule, const cha
 
 	if (logevents) {
 		if (WIFEXITED(status)) {
-			acpid_log(LOG_INFO, "action exited with status %d\n",
+			acpid_log(LOG_INFO, "action exited with status %d",
 			    WEXITSTATUS(status));
 		} else if (WIFSIGNALED(status)) {
-			acpid_log(LOG_INFO, "action exited on signal %d\n",
+			acpid_log(LOG_INFO, "action exited on signal %d",
 			    WTERMSIG(status));
 		} else {
-			acpid_log(LOG_INFO, "action exited with status %d\n",
+			acpid_log(LOG_INFO, "action exited with status %d",
 			    status);
 		}
 	}
@@ -679,7 +679,7 @@ do_client_rule(struct rule *rule, const
 	int client = rule->action.fd;
 
 	if (logevents) {
-		acpid_log(LOG_INFO, "notifying client %s\n", rule->origin);
+		acpid_log(LOG_INFO, "notifying client %s", rule->origin);
 	}
 
 	r = safe_write(client, event, strlen(event));
@@ -687,7 +687,7 @@ do_client_rule(struct rule *rule, const
 		struct ucred cred;
 		/* closed */
 		acpid_log(LOG_NOTICE,
-		    "client %s has disconnected\n", rule->origin);
+		    "client %s has disconnected", rule->origin);
 		delist_rule(&client_list, rule);
 		ud_get_peercred(rule->action.fd, &cred);
 		if (cred.uid != 0) {
@@ -728,7 +728,7 @@ safe_write(int fd, const char *buf, int
 	if (!ntries) {
 		/* crap */
 		if (acpid_debug >= 2) {
-			acpid_log(LOG_ERR, "uh-oh! safe_write() timed out\n");
+			acpid_log(LOG_ERR, "uh-oh! safe_write() timed out");
 		}
 		return r;
 	}
@@ -765,7 +765,7 @@ parse_cmd(const char *cmd, const char *e
 		buf[i++] = *p++;
 	}
 	if (acpid_debug >= 2) {
-		acpid_log(LOG_DEBUG, "expanded \"%s\" -> \"%s\"\n", cmd, buf);
+		acpid_log(LOG_DEBUG, "expanded \"%s\" -> \"%s\"", cmd, buf);
 	}
 
 	return buf;
@@ -784,11 +784,11 @@ check_escapes(const char *str)
 			p++;
 			if (!*p) {
 				acpid_log(LOG_WARNING,
-				    "invalid escape at EOL\n");
+				    "invalid escape at EOL");
 				return -1;
 			} else if (*p != '%' && *p != 'e') {
 				acpid_log(LOG_WARNING,
-				    "invalid escape \"%%%c\"\n", *p);
+				    "invalid escape \"%%%c\"", *p);
 				r = -1;
 			}
 		}
Index: acpid-2.0.8/inotify_handler.c
===================================================================
--- acpid-2.0.8.orig/inotify_handler.c
+++ acpid-2.0.8/inotify_handler.c
@@ -49,25 +49,25 @@ void process_inotify(int fd)
 
 	bytes = read(fd, &eventbuf.buffer, sizeof(eventbuf.buffer));
 
-	acpid_log(LOG_DEBUG, "inotify read bytes: %d\n", bytes);
+	acpid_log(LOG_DEBUG, "inotify read bytes: %d", bytes);
 
 	/* eof is not expected */	
 	if (bytes == 0)
 	{
-		acpid_log(LOG_WARNING, "inotify fd eof encountered\n");
+		acpid_log(LOG_WARNING, "inotify fd eof encountered");
 		return;
 	}
 	else if (bytes < 0)
 	{
 		/* EINVAL means buffer wasn't big enough.  See inotify(7). */
-		acpid_log(LOG_ERR, "inotify read error: %s (%d)\n",
+		acpid_log(LOG_ERR, "inotify read error: %s (%d)",
 			strerror(errno), errno);
-		acpid_log(LOG_ERR, "disconnecting from inotify\n");
+		acpid_log(LOG_ERR, "disconnecting from inotify");
 		delete_connection(fd);
 		return;
 	}
 
-	acpid_log(LOG_DEBUG, "inotify name len: %d\n", eventbuf.event.len);
+	acpid_log(LOG_DEBUG, "inotify name len: %d", eventbuf.event.len);
 
 	/* if a name is included */
 	if (eventbuf.event.len > 0)
@@ -80,7 +80,7 @@ void process_inotify(int fd)
 		strcat(devname, "/");
 		strncat(devname, eventbuf.event.name, dnsize - strlen(devname) - 1);
 		
-		acpid_log(LOG_DEBUG, "inotify about to open: %s\n", devname);
+		acpid_log(LOG_DEBUG, "inotify about to open: %s", devname);
 
 		open_inputfile(devname);
 	}
@@ -98,24 +98,24 @@ void open_inotify(void)
 	fd = inotify_init();
 	
 	if (fd < 0) {
-		acpid_log(LOG_ERR, "inotify_init() failed: %s (%d)\n",
+		acpid_log(LOG_ERR, "inotify_init() failed: %s (%d)",
 			strerror(errno), errno);
 		return;
 	}
 	
-	acpid_log(LOG_DEBUG, "inotify fd: %d\n", fd);
+	acpid_log(LOG_DEBUG, "inotify fd: %d", fd);
 
 	/* watch for new files being created in /dev/input */
 	wd = inotify_add_watch(fd, ACPID_INPUTLAYERDIR, IN_CREATE);
 
 	if (wd < 0) {
-		acpid_log(LOG_ERR, "inotify_add_watch() failed: %s (%d)\n",
+		acpid_log(LOG_ERR, "inotify_add_watch() failed: %s (%d)",
 			strerror(errno), errno);
 		close(fd);			
 		return;
 	}
 
-	acpid_log(LOG_DEBUG, "inotify wd: %d\n", wd);
+	acpid_log(LOG_DEBUG, "inotify wd: %d", wd);
 
 	/* add a connection to the list */
 	c.fd = fd;
Index: acpid-2.0.8/input_layer.c
===================================================================
--- acpid-2.0.8.orig/input_layer.c
+++ acpid-2.0.8/input_layer.c
@@ -191,7 +191,7 @@ void process_input(int fd)
 	nbytes = read(fd, &event, sizeof(event));
 
 	if (nbytes == 0) {
-		acpid_log(LOG_WARNING, "input layer connection closed\n");
+		acpid_log(LOG_WARNING, "input layer connection closed");
 		exit(EXIT_FAILURE);
 	}
 	
@@ -200,16 +200,16 @@ void process_input(int fd)
 		if (errno == EINTR)
 			return;
 		if (errno == ENODEV) {
-			acpid_log(LOG_WARNING, "input device has been disconnected\n");
+			acpid_log(LOG_WARNING, "input device has been disconnected");
 			delete_connection(fd);
 			return;
 		}
-		acpid_log(LOG_ERR, "input layer read error: %s (%d)\n",
+		acpid_log(LOG_ERR, "input layer read error: %s (%d)",
 			strerror(errno), errno);
 		if (++nerrs >= ACPID_MAX_ERRS) {
 			acpid_log(LOG_ERR,
 				"too many errors reading "
-				"input layer - aborting\n");
+				"input layer - aborting");
 			exit(EXIT_FAILURE);
 		}
 		return;
@@ -220,7 +220,7 @@ void process_input(int fd)
 	
 	if (nbytes != sizeof(event)) {
 		acpid_log(LOG_WARNING, "input layer unexpected length: "
-			"%d   expected: %d\n", nbytes, sizeof(event));
+			"%d   expected: %d", nbytes, sizeof(event));
 		return;
 	}
 
@@ -235,21 +235,21 @@ void process_input(int fd)
 		if (logevents) {
 			acpid_log(LOG_INFO,
 				"lockfile present, not processing "
-				"input layer event \"%s\"\n", str);
+				"input layer event \"%s\"", str);
 		}
 		return;
 	}
 
 	if (logevents)
 		acpid_log(LOG_INFO,
-			"received input layer event \"%s\"\n", str);
+			"received input layer event \"%s\"", str);
 	
 	/* send the event off to the handler */
 	acpid_handle_event(str);
 
 	if (logevents)
 		acpid_log(LOG_INFO,
-			"completed input layer event \"%s\"\n", str);
+			"completed input layer event \"%s\"", str);
 }
 
 #define BITS_PER_LONG (sizeof(long) * 8)
@@ -314,7 +314,7 @@ int open_inputfile(const char *filename)
 		}
 
 		acpid_log(LOG_DEBUG, "input layer %s "
-			"opened successfully\n", filename);
+			"opened successfully", filename);
 
 		/* add a connection to the list */
 		c.fd = fd;
@@ -350,7 +350,7 @@ void open_input(void)
 	}
 
 	if (!success)
-		acpid_log(LOG_ERR, "cannot open input layer\n");
+		acpid_log(LOG_ERR, "cannot open input layer");
 
 	globfree(&globbuf);
 }
Index: acpid-2.0.8/netlink.c
===================================================================
--- acpid-2.0.8.orig/netlink.c
+++ acpid-2.0.8/netlink.c
@@ -57,7 +57,7 @@ format_netlink(struct nlmsghdr *msg)
 	/* if this message doesn't have the proper family ID, drop it */
 	if (msg->nlmsg_type != acpi_ids_getfamily()) {
 		if (logevents) {
-			acpid_log(LOG_INFO, "wrong netlink family ID.\n");
+			acpid_log(LOG_INFO, "wrong netlink family ID.");
 		}
 		return;
 	}
@@ -66,7 +66,7 @@ format_netlink(struct nlmsghdr *msg)
 
 	if (len < 0) {
 		acpid_log(LOG_WARNING,
-			"wrong netlink controller message len: %d\n", len);
+			"wrong netlink controller message len: %d", len);
 		return;
 	}
 
@@ -90,21 +90,21 @@ format_netlink(struct nlmsghdr *msg)
 			if (logevents) {
 				acpid_log(LOG_INFO,
 					"lockfile present, not processing "
-					"netlink event \"%s\"\n", buf);
+					"netlink event \"%s\"", buf);
 			}
 			return;
 		}
 
 		if (logevents)
 			acpid_log(LOG_INFO,
-				"received netlink event \"%s\"\n", buf);
+				"received netlink event \"%s\"", buf);
 
 		/* send the event off to the handler */
 		acpid_handle_event(buf);
 
 		if (logevents)
 			acpid_log(LOG_INFO,
-				"completed netlink event \"%s\"\n", buf);
+				"completed netlink event \"%s\"", buf);
 	}
 }
 
@@ -148,25 +148,25 @@ process_netlink(int fd)
 		if (errno == EINTR)
 			return;
 		
-		acpid_log(LOG_ERR, "netlink read error: %s (%d)\n",
+		acpid_log(LOG_ERR, "netlink read error: %s (%d)",
 			strerror(errno), errno);
 		if (++nerrs >= ACPID_MAX_ERRS) {
 			acpid_log(LOG_ERR,
 				"too many errors reading via "
-				"netlink - aborting\n");
+				"netlink - aborting");
 			exit(EXIT_FAILURE);
 		}
 		return;
 	}
 	/* if an orderly shutdown has occurred, we're done */
 	if (status == 0) {
-		acpid_log(LOG_WARNING, "netlink connection closed\n");
+		acpid_log(LOG_WARNING, "netlink connection closed");
 		exit(EXIT_FAILURE);
 	}
 	/* check to see if the address length has changed */
 	if (msg.msg_namelen != sizeof(nladdr)) {
 		acpid_log(LOG_WARNING, "netlink unexpected length: "
-			"%d   expected: %d\n", msg.msg_namelen, sizeof(nladdr));
+			"%d   expected: %d", msg.msg_namelen, sizeof(nladdr));
 		return;
 	}
 	
@@ -177,11 +177,11 @@ process_netlink(int fd)
 
 		if (l < 0  ||  len > status) {
 			if (msg.msg_flags & MSG_TRUNC) {
-				acpid_log(LOG_WARNING, "netlink msg truncated (1)\n");
+				acpid_log(LOG_WARNING, "netlink msg truncated (1)");
 				return;
 			}
 			acpid_log(LOG_WARNING,
-				"malformed netlink msg, length %d\n", len);
+				"malformed netlink msg, length %d", len);
 			return;
 		}
 
@@ -192,11 +192,11 @@ process_netlink(int fd)
 		h = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));
 	}
 	if (msg.msg_flags & MSG_TRUNC) {
-		acpid_log(LOG_WARNING, "netlink msg truncated (2)\n");
+		acpid_log(LOG_WARNING, "netlink msg truncated (2)");
 		return;
 	}
 	if (status) {
-		acpid_log(LOG_WARNING, "netlink remnant of size %d\n", status);
+		acpid_log(LOG_WARNING, "netlink remnant of size %d", status);
 		return;
 	}
 
@@ -209,7 +209,7 @@ static __u32
 nl_mgrp(__u32 group)
 {
 	if (group > 31) {
-		acpid_log(LOG_ERR, "Unexpected group number %d\n", group);
+		acpid_log(LOG_ERR, "Unexpected group number %d", group);
 		return 0;
 	}
 	return group ? (1 << (group - 1)) : 0;
@@ -223,11 +223,11 @@ void open_netlink(void)
 	/* open the appropriate netlink socket for input */
 	if (rtnl_open_byproto(
 		&rth, nl_mgrp(acpi_ids_getgroup()), NETLINK_GENERIC) < 0) {
-		acpid_log(LOG_ERR, "cannot open generic netlink socket\n");
+		acpid_log(LOG_ERR, "cannot open generic netlink socket");
 		return;
 	}
 
-	acpid_log(LOG_DEBUG, "netlink opened successfully\n");
+	acpid_log(LOG_DEBUG, "netlink opened successfully");
 
 	/* add a connection to the list */
 	c.fd = rth.fd;
Index: acpid-2.0.8/proc.c
===================================================================
--- acpid-2.0.8.orig/proc.c
+++ acpid-2.0.8/proc.c
@@ -48,7 +48,7 @@ process_proc(int fd)
 		if (logevents  &&  event != NULL) {
 			acpid_log(LOG_INFO,
 				"lockfile present, not processing "
-				"event \"%s\"\n", event);
+				"event \"%s\"", event);
 		}
 		return;
 	}
@@ -57,23 +57,23 @@ process_proc(int fd)
 	if (event) {
 		if (logevents) {
 			acpid_log(LOG_INFO,
-			          "procfs received event \"%s\"\n", event);
+			          "procfs received event \"%s\"", event);
 		}
 		acpid_handle_event(event);
 		if (logevents) {
 			acpid_log(LOG_INFO,
-				"procfs completed event \"%s\"\n", event);
+				"procfs completed event \"%s\"", event);
 		}
 	} else if (errno == EPIPE) {
 		acpid_log(LOG_WARNING,
-			"events file connection closed\n");
+			"events file connection closed");
 		exit(EXIT_FAILURE);
 	} else {
 		static int nerrs;
 		if (++nerrs >= ACPID_MAX_ERRS) {
 			acpid_log(LOG_ERR,
 				"too many errors reading "
-				"events file - aborting\n");
+				"events file - aborting");
 			exit(EXIT_FAILURE);
 		}
 	}
@@ -89,9 +89,9 @@ open_proc()
 	if (fd < 0) {
 		if (errno == ENOENT) {
 			acpid_log(LOG_DEBUG, "Deprecated %s was not found.  "
-				"Trying netlink and the input layer...\n", eventfile);
+				"Trying netlink and the input layer...", eventfile);
 		} else {
-			acpid_log(LOG_ERR, "can't open %s: %s (%d)\n", eventfile, 
+			acpid_log(LOG_ERR, "can't open %s: %s (%d)", eventfile, 
 				strerror(errno), errno);
 		}
 		return -1;
@@ -102,7 +102,7 @@ open_proc()
        descriptors. */
     fcntl(fd, F_SETFD, FD_CLOEXEC);
 
-	acpid_log(LOG_DEBUG, "proc fs opened successfully\n");
+	acpid_log(LOG_DEBUG, "proc fs opened successfully");
 
 	/* add a connection to the list */
 	c.fd = fd;
@@ -132,7 +132,7 @@ read_line(int fd)
 			r = read(fd, buf+i, 1);
 			if (r < 0 && errno != EINTR) {
 				/* we should do something with the data */
-				acpid_log(LOG_ERR, "read(): %s\n",
+				acpid_log(LOG_ERR, "read(): %s",
 					strerror(errno));
 				return NULL;
 			} else if (r == 0) {
@@ -176,7 +176,7 @@ read_line(int fd)
 		/* ??? This memory is leaked since it is never freed */
 		buf = realloc(buf, buflen);
 		if (!buf) {
-			acpid_log(LOG_ERR, "malloc(%d): %s\n",
+			acpid_log(LOG_ERR, "malloc(%d): %s",
 				buflen, strerror(errno));
 			return NULL;
 		}
@@ -186,7 +186,7 @@ read_line(int fd)
 			r = read(fd, buf+i, 1);
 			if (r < 0 && errno != EINTR) {
 				/* we should do something with the data */
-				acpid_log(LOG_ERR, "read(): %s\n",
+				acpid_log(LOG_ERR, "read(): %s",
 					strerror(errno));
 				return NULL;
 			} else if (r == 0) {
Index: acpid-2.0.8/sock.c
===================================================================
--- acpid-2.0.8.orig/sock.c
+++ acpid-2.0.8/sock.c
@@ -53,11 +53,11 @@ process_sock(int fd)
 	/* accept and add to our lists */
 	cli_fd = ud_accept(fd, &creds);
 	if (cli_fd < 0) {
-		acpid_log(LOG_ERR, "can't accept client: %s\n",
+		acpid_log(LOG_ERR, "can't accept client: %s",
 			  strerror(errno));
 		accept_errors++;
 		if (accept_errors >= 5) {
-			acpid_log(LOG_ERR, "giving up\n");
+			acpid_log(LOG_ERR, "giving up");
 			clean_exit_with_status(EXIT_FAILURE);
 		}
 		return;
@@ -67,7 +67,7 @@ process_sock(int fd)
 	if (creds.uid != 0 && non_root_clients >= clientmax) {
 		close(cli_fd);
 		acpid_log(LOG_ERR,
-		    "too many non-root clients\n");
+		    "too many non-root clients");
 		return;
 	}
 	if (creds.uid != 0) {
@@ -87,7 +87,7 @@ open_sock()
 
 	fd = ud_create_socket(socketfile);
 	if (fd < 0) {
-		acpid_log(LOG_ERR, "can't open socket %s: %s\n",
+		acpid_log(LOG_ERR, "can't open socket %s: %s",
 			socketfile, strerror(errno));
 		exit(EXIT_FAILURE);
 	}
@@ -98,15 +98,15 @@ open_sock()
 		struct stat buf;
 		gr = getgrnam(socketgroup);
 		if (!gr) {
-			acpid_log(LOG_ERR, "group %s does not exist\n", socketgroup);
+			acpid_log(LOG_ERR, "group %s does not exist", socketgroup);
 			exit(EXIT_FAILURE);
 		}
 		if (stat(socketfile, &buf) < 0) {
-			acpid_log(LOG_ERR, "can't stat %s\n", socketfile);
+			acpid_log(LOG_ERR, "can't stat %s", socketfile);
 			exit(EXIT_FAILURE);
 		}
 		if (chown(socketfile, buf.st_uid, gr->gr_gid) < 0) {
-			acpid_log(LOG_ERR, "can't chown: %s\n", strerror(errno));
+			acpid_log(LOG_ERR, "can't chown: %s", strerror(errno));
 			exit(EXIT_FAILURE);
 		}
 	}
