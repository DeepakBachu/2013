--- kdenetwork-4.6.0/kopete/libkopete/avdevice/videodevice.cpp	2011-01-20 00:20:41.000000000 +0200
+++ kdenetwork-4.6.0/kopete/libkopete/avdevice/videodevice.cpp	2011-02-09 23:58:15.000000000 +0200
@@ -117,30 +117,6 @@
 			}
 			break;
 #endif
-		case VIDEODEV_DRIVER_V4L:
-			{
-				NumericVideoControl numCtrl;
-				numCtrl.value_min = 0;
-				numCtrl.value_max = 65535;
-				numCtrl.value_step = 1;
-				numCtrl.value_default = 32767;
-				numCtrl.id = IMGCTRL_ID_V4L1_BRIGHTNESS;
-				numCtrl.name = i18n("Brightness");
-				m_numericCtrls.push_back( numCtrl );
-				numCtrl.id = IMGCTRL_ID_V4L1_HUE;
-				numCtrl.name = i18n("Hue");
-				m_numericCtrls.push_back( numCtrl );
-				numCtrl.id = IMGCTRL_ID_V4L1_COLOR;
-				numCtrl.name = i18n("Color");
-				m_numericCtrls.push_back( numCtrl );
-				numCtrl.id = IMGCTRL_ID_V4L1_CONTRAST;
-				numCtrl.name = i18n("Contrast");
-				m_numericCtrls.push_back( numCtrl );
-				numCtrl.id = IMGCTRL_ID_V4L1_WHITENESS;
-				numCtrl.name = i18n("Whiteness");
-				m_numericCtrls.push_back( numCtrl );
-			}
-			break;
 #endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
@@ -486,69 +462,6 @@
 
 #endif
 
-		CLEAR(V4L_capabilities);
-
-		if(m_driver==VIDEODEV_DRIVER_NONE)
-		{
-			kDebug() << "checkDevice(): " << full_filename << " Trying V4L API.";
-			if (-1 == xioctl (VIDIOCGCAP, &V4L_capabilities))
-			{
-				perror ("ioctl (VIDIOCGCAP)");
-				m_driver = VIDEODEV_DRIVER_NONE;
-				return EXIT_FAILURE;
-			}
-			else
-			{
-				kDebug() << full_filename << " is a V4L device.";
-				m_driver = VIDEODEV_DRIVER_V4L;
-				m_model=QString::fromLocal8Bit((const char*)V4L_capabilities.name);
-				if(V4L_capabilities.type & VID_TYPE_CAPTURE)
-					m_videocapture=true;
-				if(V4L_capabilities.type & VID_TYPE_CHROMAKEY)
-					m_videochromakey=true;
-				if(V4L_capabilities.type & VID_TYPE_SCALES)
-					m_videoscale=true;	
-				if(V4L_capabilities.type & VID_TYPE_OVERLAY)
-					m_videooverlay=true;
-//				kDebug() << "libkopete (avdevice):     Inputs : " << V4L_capabilities.channels;
-//				kDebug() << "libkopete (avdevice):     Audios : " << V4L_capabilities.audios;
-				minwidth  = V4L_capabilities.minwidth;
-				maxwidth  = V4L_capabilities.maxwidth;
-				minheight = V4L_capabilities.minheight;
-				maxheight = V4L_capabilities.maxheight;
-
-
-				int inputisok=EXIT_SUCCESS;
-				m_input.clear();
-				for(int loop=0; loop < V4L_capabilities.channels; loop++)
-				{
-					struct video_channel videoinput;
-					CLEAR(videoinput);
-					videoinput.channel = loop;
-					videoinput.norm    = 1;
-					inputisok=xioctl(VIDIOCGCHAN, &videoinput);
-					if(inputisok==EXIT_SUCCESS)
-					{
-						VideoInput tempinput;
-						tempinput.name = QString::fromLocal8Bit((const char*)videoinput.name);
-						tempinput.hastuner=videoinput.flags & VIDEO_VC_TUNER;
-// TODO: The routine to detect the appropriate video standards for V4L must be placed here
-						m_input.push_back(tempinput);
-//						kDebug() << "libkopete (avdevice): Input " << loop << ": " << tempinput.name << " (tuner: " << ((videoinput.flags & VIDEO_VC_TUNER) != 0) << ")";
-/*						if((input.type & V4L2_INPUT_TYPE_TUNER) != 0)
-						{
-//							_tunerForInput[name] = desc.tuner;
-//							_isTuner = true;
-						}
-						else
-						{
-//							_tunerForInput[name] = -1;
-						}
-*/					}
-				}
-
-			}
-		}
 #endif
 		m_name=m_model; // Take care about changing the name to be different from the model itself...
 
@@ -678,16 +591,6 @@
 			}
 			break;
 #endif
-		case VIDEODEV_DRIVER_V4L:
-			m_videoread=true;
-			m_io_method=IO_METHOD_READ;
-			if(-1 != xioctl(VIDIOCGFBUF,&V4L_videobuffer))
-			{
-//				m_videostream=true;
-//				m_io_method = IO_METHOD_MMAP;
-				kDebug() << "    Streaming interface";
-			}
-			break;
 #endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
@@ -863,35 +766,6 @@
 				}
 				break;
 #endif
-			case VIDEODEV_DRIVER_V4L:
-				{
-					struct video_window V4L_videowindow;
-
-				if (xioctl (VIDIOCGWIN, &V4L_videowindow)== -1)
-				{
-					perror ("ioctl VIDIOCGWIN");
-//					return (NULL);
-				}
-				V4L_videowindow.width  = newwidth;
-				V4L_videowindow.height = newheight;
-				V4L_videowindow.clipcount=0;
-				if (xioctl (VIDIOCSWIN, &V4L_videowindow)== -1)
-				{
-					perror ("ioctl VIDIOCSWIN");
-					return EXIT_FAILURE;
-				}
-kDebug() << "------------- width: " << V4L_videowindow.width << " Height: " << V4L_videowindow.height << " Clipcount: " << V4L_videowindow.clipcount << " -----------------";
-
-				currentwidth  = V4L_videowindow.width;
-				currentheight = V4L_videowindow.height;
-
-//				kDebug() << "libkopete (avdevice): V4L_picture.palette: " << V4L_picture.palette << " Depth: " << V4L_picture.depth;
-
-/*				if(-1 == xioctl(VIDIOCGFBUF,&V4L_videobuffer))
-					kDebug() << "libkopete (avdevice): VIDIOCGFBUF failed (" << errno << "): Device cannot stream";*/
-
-				}
-				break;
 #endif
 			case VIDEODEV_DRIVER_NONE:
 			default:
@@ -966,33 +840,6 @@
 			}
 			break;
 #endif
-		case VIDEODEV_DRIVER_V4L:
-			{
-			struct video_picture V4L_picture;
-			if(-1 == xioctl(VIDIOCGPICT, &V4L_picture))
-			{
-				kDebug() << "VIDIOCGPICT failed (" << errno << ").";
-			}
-//			kDebug() << "V4L_picture.palette: " << V4L_picture.palette << " Depth: " << V4L_picture.depth;
-			V4L_picture.palette = pixelFormatCode(newformat);
-			V4L_picture.depth   = pixelFormatDepth(newformat);
-			if(-1 == xioctl(VIDIOCSPICT,&V4L_picture))
-			{
-//				kDebug() << "Device seems to not support " << pixelFormatName(newformat) << " format. Fallback to it is not yet implemented.";
-			}
-
-			if(-1 == xioctl(VIDIOCGPICT, &V4L_picture))
-			{
-				kDebug() << "VIDIOCGPICT failed (" << errno << ").";
-			}
-
-//			kDebug() << "V4L_picture.palette: " << V4L_picture.palette << " Depth: " << V4L_picture.depth;
-			m_pixelformat=pixelFormatForPalette(V4L_picture.palette);
-			if (m_pixelformat == newformat)
-				ret = newformat;
-
-			}
-			break;
 #endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
@@ -1043,17 +890,6 @@
 				setupControls();
 				break;
 #endif
-			case VIDEODEV_DRIVER_V4L:
-				struct video_channel V4L_input;
-				V4L_input.channel=newinput;
-				V4L_input.norm=4; // Hey, it's plain wrong! It should be input's signal standard!
-				if (-1 == ioctl (descriptor, VIDIOCSCHAN, &V4L_input))
-				{
-					perror ("ioctl (VIDIOCSCHAN)");
-					return EXIT_FAILURE;
-				}
-				setupControls();
-				break;
 #endif
 			case VIDEODEV_DRIVER_NONE:
 			default:
@@ -1817,35 +1653,6 @@
 			}
 			break;
 #endif
-		case VIDEODEV_DRIVER_V4L:
-			struct video_picture V4L_picture;
-			if(-1 == xioctl(VIDIOCGPICT, &V4L_picture))
-			{
-				kDebug() << "VIDIOCGPICT failed (" << errno << ").";
-				return EXIT_FAILURE;
-			}
-			switch (ctrl_id)
-			{
-				case IMGCTRL_ID_V4L1_BRIGHTNESS:
-					*value = V4L_picture.brightness;
-					break;
-				case IMGCTRL_ID_V4L1_HUE:
-					*value = V4L_picture.hue;
-					break;
-				case IMGCTRL_ID_V4L1_COLOR:
-					*value = V4L_picture.colour;
-					break;
-				case IMGCTRL_ID_V4L1_CONTRAST:
-					*value = V4L_picture.contrast;
-					break;
-				case IMGCTRL_ID_V4L1_WHITENESS:
-					*value = V4L_picture.whiteness;
-					break;
-				default:
-					return EXIT_FAILURE;
-			}
-			kDebug() << "Reported current value is" << *value << ".";
-			return EXIT_SUCCESS;
 #endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
@@ -1963,50 +1770,6 @@
 			}
 			break;
 #endif
-		case VIDEODEV_DRIVER_V4L:
-			struct video_picture V4L_picture;
-			if(-1 == xioctl(VIDIOCGPICT, &V4L_picture))
-			{
-				kDebug() << "VIDIOCGPICT failed (" << errno << ").";
-				return EXIT_FAILURE;
-			}
-			if (value < 0)
-			{
-				value = 0;
-				kDebug() << "Value exceeds lower limit ! Setting to minimum: 0";
-			}
-			else if (value > 65535)
-			{
-				value = 65535;
-				kDebug() << "Value exceeds upper limit ! Setting to maximum: 65535";
-			}
-			// TODO: consider step, too ?
-			switch (ctrl_id)
-			{
-				case IMGCTRL_ID_V4L1_BRIGHTNESS:
-					V4L_picture.brightness = value;
-					break;
-				case IMGCTRL_ID_V4L1_HUE:
-					V4L_picture.hue = value;
-					break;
-				case IMGCTRL_ID_V4L1_COLOR:
-					V4L_picture.colour = value;
-					break;
-				case IMGCTRL_ID_V4L1_CONTRAST:
-					V4L_picture.contrast = value;
-					break;
-				case IMGCTRL_ID_V4L1_WHITENESS:
-					V4L_picture.whiteness = value;
-					break;
-				default:
-					return EXIT_FAILURE;
-			}
-			if(-1 == xioctl(VIDIOCSPICT,&V4L_picture))
-			{
-				kDebug() << "Device seems to not support adjusting image brightness. Fallback to it is not yet implemented.";
-				return EXIT_FAILURE;
-			}
-			return EXIT_SUCCESS;
 #endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
@@ -2070,23 +1833,6 @@
 			}
 			break;
 #endif
-		case VIDEODEV_DRIVER_V4L:
-			switch(palette)
-			{
-				case 0				: return PIXELFORMAT_NONE;	break;
-				case VIDEO_PALETTE_GREY		: return PIXELFORMAT_GREY;	break;
-				case VIDEO_PALETTE_HI240	: return PIXELFORMAT_RGB332;	break;
-				case VIDEO_PALETTE_RGB555	: return PIXELFORMAT_RGB555;	break;
-				case VIDEO_PALETTE_RGB565	: return PIXELFORMAT_RGB565;	break;
-				case VIDEO_PALETTE_RGB24	: return PIXELFORMAT_RGB24;	break;
-				case VIDEO_PALETTE_RGB32	: return PIXELFORMAT_RGB32;	break;
-				case VIDEO_PALETTE_YUYV		: return PIXELFORMAT_YUYV;	break;
-				case VIDEO_PALETTE_UYVY		: return PIXELFORMAT_UYVY;	break;
-				case VIDEO_PALETTE_YUV420	:
-				case VIDEO_PALETTE_YUV420P	: return PIXELFORMAT_YUV420P;	break;
-				case VIDEO_PALETTE_YUV422P	: return PIXELFORMAT_YUV422P;	break;
-			}
-			break;
 #endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
@@ -2150,50 +1896,6 @@
 			}
 			break;
 #endif
-		case VIDEODEV_DRIVER_V4L:
-			switch(pixelformat)
-			{
-				case PIXELFORMAT_NONE	: return 0;			break;
-
-// Packed RGB formats
-				case PIXELFORMAT_RGB332	: return VIDEO_PALETTE_HI240;	break;
-				case PIXELFORMAT_RGB444	: return 0;			break;
-				case PIXELFORMAT_RGB555	: return VIDEO_PALETTE_RGB555;	break;
-				case PIXELFORMAT_RGB565	: return VIDEO_PALETTE_RGB565;	break;
-				case PIXELFORMAT_RGB555X: return 0;			break;
-				case PIXELFORMAT_RGB565X: return 0;			break;
-				case PIXELFORMAT_BGR24	: return 0;			break;
-				case PIXELFORMAT_RGB24	: return VIDEO_PALETTE_RGB24;	break;
-				case PIXELFORMAT_BGR32	: return 0;			break;
-				case PIXELFORMAT_RGB32	: return VIDEO_PALETTE_RGB32;	break;
-
-// Bayer RGB format
-				case PIXELFORMAT_SBGGR8	: return 0;			break;
-
-// YUV formats
-				case PIXELFORMAT_GREY	: return VIDEO_PALETTE_GREY;	break;
-				case PIXELFORMAT_YUYV	: return VIDEO_PALETTE_YUYV;	break;
-				case PIXELFORMAT_UYVY	: return VIDEO_PALETTE_UYVY;	break;
-				case PIXELFORMAT_YUV420P: return VIDEO_PALETTE_YUV420;	break;
-				case PIXELFORMAT_YUV422P: return VIDEO_PALETTE_YUV422P;	break;
-
-// Compressed formats
-				case PIXELFORMAT_JPEG	: return 0;			break;
-				case PIXELFORMAT_MPEG	: return 0;			break;
-
-// Reserved formats
-				case PIXELFORMAT_DV	: return 0;			break;
-				case PIXELFORMAT_ET61X251:return 0;			break;
-				case PIXELFORMAT_HI240	: return VIDEO_PALETTE_HI240;	break;
-				case PIXELFORMAT_HM12	: return 0;			break;
-				case PIXELFORMAT_MJPEG	: return 0;			break;
-				case PIXELFORMAT_PWC1	: return 0;			break;
-				case PIXELFORMAT_PWC2	: return 0;			break;
-				case PIXELFORMAT_SN9C10X: return 0;			break;
-				case PIXELFORMAT_WNVA	: return 0;			break;
-				case PIXELFORMAT_YYUV	: return 0;			break;
-			}
-			break;
 #endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
@@ -2356,22 +2058,6 @@
 			}
 			break;
 #endif
-		case VIDEODEV_DRIVER_V4L:
-			switch(pixelformat)
-			{
-				case VIDEO_PALETTE_GREY		: returnvalue = pixelFormatName(PIXELFORMAT_GREY);	break;
-				case VIDEO_PALETTE_HI240	: returnvalue = pixelFormatName(PIXELFORMAT_RGB332);	break;
-				case VIDEO_PALETTE_RGB555	: returnvalue = pixelFormatName(PIXELFORMAT_RGB555);	break;
-				case VIDEO_PALETTE_RGB565	: returnvalue = pixelFormatName(PIXELFORMAT_RGB565);	break;
-				case VIDEO_PALETTE_RGB24	: returnvalue = pixelFormatName(PIXELFORMAT_RGB24);	break;
-				case VIDEO_PALETTE_RGB32	: returnvalue = pixelFormatName(PIXELFORMAT_RGB32);	break;
-				case VIDEO_PALETTE_YUYV		: returnvalue = pixelFormatName(PIXELFORMAT_YUYV);	break;
-				case VIDEO_PALETTE_UYVY		: returnvalue = pixelFormatName(PIXELFORMAT_UYVY);	break;
-				case VIDEO_PALETTE_YUV420	:
-				case VIDEO_PALETTE_YUV420P	: returnvalue = pixelFormatName(PIXELFORMAT_YUV420P);	break;
-				case VIDEO_PALETTE_YUV422P	: returnvalue = pixelFormatName(PIXELFORMAT_YUV422P);	break;
-			}
-			break;
 #endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
@@ -2408,49 +2094,6 @@
 			}
 //			break;
 #endif
-		case VIDEODEV_DRIVER_V4L:
-// TODO: THis thing can be used to detec what pixel formats are supported in a API-independent way, but V4L2 has VIDIOC_ENUM_PIXFMT.
-// The correct thing to do is to isolate these calls and do a proper implementation for V4L and another for V4L2 when this thing will be migrated to a plugin architecture.
-
-// Packed RGB formats
-			kDebug() << "Supported pixel formats:";
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB332))	{ kDebug() << pixelFormatName(PIXELFORMAT_RGB332); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB444))	{ kDebug() << pixelFormatName(PIXELFORMAT_RGB444); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB555))	{ kDebug() << pixelFormatName(PIXELFORMAT_RGB555); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB565))	{ kDebug() << pixelFormatName(PIXELFORMAT_RGB565); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB555X))	{ kDebug() << pixelFormatName(PIXELFORMAT_RGB555X); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB565X))	{ kDebug() << pixelFormatName(PIXELFORMAT_RGB565X); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_BGR24))	{ kDebug() << pixelFormatName(PIXELFORMAT_BGR24); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB24))	{ kDebug() << pixelFormatName(PIXELFORMAT_RGB24); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_BGR32))	{ kDebug() << pixelFormatName(PIXELFORMAT_BGR32); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_RGB32))	{ kDebug() << pixelFormatName(PIXELFORMAT_RGB32); }
-
-// Bayer RGB format
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_SBGGR8))	{ kDebug() << pixelFormatName(PIXELFORMAT_SBGGR8); }
-
-// YUV formats
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_GREY))	{ kDebug() << pixelFormatName(PIXELFORMAT_GREY); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_YUYV))	{ kDebug() << pixelFormatName(PIXELFORMAT_YUYV); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_UYVY))	{ kDebug() << pixelFormatName(PIXELFORMAT_UYVY); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_YUV420P))	{ kDebug() << pixelFormatName(PIXELFORMAT_YUV420P); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_YUV422P))	{ kDebug() << pixelFormatName(PIXELFORMAT_YUV422P); }
-
-// Compressed formats
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_JPEG))	{ kDebug() << pixelFormatName(PIXELFORMAT_JPEG); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_MPEG))	{ kDebug() << pixelFormatName(PIXELFORMAT_MPEG); }
-
-// Reserved formats
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_DV))		{ kDebug() << pixelFormatName(PIXELFORMAT_DV); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_ET61X251))	{ kDebug() << pixelFormatName(PIXELFORMAT_ET61X251); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_HI240))	{ kDebug() << pixelFormatName(PIXELFORMAT_HI240); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_HM12))	{ kDebug() << pixelFormatName(PIXELFORMAT_HM12); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_MJPEG))	{ kDebug() << pixelFormatName(PIXELFORMAT_MJPEG); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_PWC1))	{ kDebug() << pixelFormatName(PIXELFORMAT_PWC1); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_PWC2))	{ kDebug() << pixelFormatName(PIXELFORMAT_PWC2); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_SN9C10X))	{ kDebug() << pixelFormatName(PIXELFORMAT_SN9C10X); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_WNVA))	{ kDebug() << pixelFormatName(PIXELFORMAT_WNVA); }
-			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_YYUV))	{ kDebug() << pixelFormatName(PIXELFORMAT_YYUV); }
-			break;
 #endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
@@ -2520,60 +2163,6 @@
 			}
 			break;
 #endif
-		case VIDEODEV_DRIVER_V4L:
-			switch(standard)
-			{
-				case STANDARD_PAL_B	: return VIDEO_MODE_PAL;	break;
-				case STANDARD_PAL_B1	: return VIDEO_MODE_PAL;	break;
-				case STANDARD_PAL_G	: return VIDEO_MODE_PAL;	break;
-				case STANDARD_PAL_H	: return VIDEO_MODE_PAL;	break;
-				case STANDARD_PAL_I	: return VIDEO_MODE_PAL;	break;
-				case STANDARD_PAL_D	: return VIDEO_MODE_PAL;	break;
-				case STANDARD_PAL_D1	: return VIDEO_MODE_PAL;	break;
-				case STANDARD_PAL_K	: return VIDEO_MODE_PAL;	break;
-
-				case STANDARD_PAL_M	: return 5;	break;	// Undocumented value found to be compatible with V4L bttv driver
-				case STANDARD_PAL_N	: return 6;	break;	// Undocumented value found to be compatible with V4L bttv driver
-				case STANDARD_PAL_Nc	: return 4;	break;	// Undocumented value found to be compatible with V4L bttv driver
-				case STANDARD_PAL_60	: return VIDEO_MODE_PAL;	break;
-
-				case STANDARD_NTSC_M	: return VIDEO_MODE_NTSC;	break;
-				case STANDARD_NTSC_M_JP	: return 7;	break;	// Undocumented value found to be compatible with V4L bttv driver
-				case STANDARD_NTSC_443	: return VIDEO_MODE_NTSC;	break;
-				case STANDARD_NTSC_M_KR	: return VIDEO_MODE_NTSC;	break;
-
-				case STANDARD_SECAM_B	: return VIDEO_MODE_SECAM;	break;
-				case STANDARD_SECAM_D	: return VIDEO_MODE_SECAM;	break;
-				case STANDARD_SECAM_G	: return VIDEO_MODE_SECAM;	break;
-				case STANDARD_SECAM_H	: return VIDEO_MODE_SECAM;	break;
-				case STANDARD_SECAM_K	: return VIDEO_MODE_SECAM;	break;
-				case STANDARD_SECAM_K1	: return VIDEO_MODE_SECAM;	break;
-				case STANDARD_SECAM_L	: return VIDEO_MODE_SECAM;	break;
-				case STANDARD_SECAM_LC	: return VIDEO_MODE_SECAM;	break;
-
-				case STANDARD_ATSC_8_VSB: return VIDEO_MODE_AUTO;	break;
-				case STANDARD_ATSC_16_VSB:return VIDEO_MODE_AUTO;	break;
-
-				case STANDARD_PAL_BG	: return VIDEO_MODE_PAL;	break;
-				case STANDARD_PAL_DK	: return VIDEO_MODE_PAL;	break;
-				case STANDARD_PAL	: return VIDEO_MODE_PAL;	break;
-				case STANDARD_NTSC	: return VIDEO_MODE_NTSC;	break;
-				case STANDARD_SECAM_DK	: return VIDEO_MODE_SECAM;	break;
-				case STANDARD_SECAM	: return VIDEO_MODE_SECAM;	break;
-
-				case STANDARD_MN	: return VIDEO_MODE_AUTO;	break;
-				case STANDARD_B		: return VIDEO_MODE_AUTO;	break;
-				case STANDARD_GH	: return VIDEO_MODE_AUTO;	break;
-				case STANDARD_DK	: return VIDEO_MODE_AUTO;	break;
-
-				case STANDARD_525_60	: return VIDEO_MODE_PAL;	break;
-				case STANDARD_625_50	: return VIDEO_MODE_SECAM;	break;
-				case STANDARD_ATSC	: return VIDEO_MODE_AUTO;	break;
-
-				case STANDARD_UNKNOWN	: return VIDEO_MODE_AUTO;	break;
-				case STANDARD_ALL	: return VIDEO_MODE_AUTO;	break;
-			}
-			break;
 #endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
@@ -2701,19 +2290,6 @@
 			}
 			break;
 #endif
-		case VIDEODEV_DRIVER_V4L:
-			switch(standard)
-			{
-				case VIDEO_MODE_PAL	: returnvalue = signalStandardName(STANDARD_PAL);	break;
-				case VIDEO_MODE_NTSC	: returnvalue = signalStandardName(STANDARD_NTSC);	break;
-				case VIDEO_MODE_SECAM	: returnvalue = signalStandardName(STANDARD_SECAM);	break;
-				case VIDEO_MODE_AUTO	: returnvalue = signalStandardName(STANDARD_ALL);	break;	// It must be disabled until I find a correct way to handle those non-standard bttv modes
-//				case VIDEO_MODE_PAL_Nc	: returnvalue = signalStandardName(STANDARD_PAL_Nc);	break;	// Undocumented value found to be compatible with V4L bttv driver
-				case VIDEO_MODE_PAL_M	: returnvalue = signalStandardName(STANDARD_PAL_M);	break;	// Undocumented value found to be compatible with V4L bttv driver
-				case VIDEO_MODE_PAL_N	: returnvalue = signalStandardName(STANDARD_PAL_N);	break;	// Undocumented value found to be compatible with V4L bttv driver
-				case VIDEO_MODE_NTSC_JP	: returnvalue = signalStandardName(STANDARD_NTSC_M_JP);	break;	// Undocumented value found to be compatible with V4L bttv driver
-			}
-			break;
 #endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
@@ -2779,8 +2355,6 @@
 
 				break;
 #endif
-			case VIDEODEV_DRIVER_V4L:
-				break;
 #endif
 			case VIDEODEV_DRIVER_NONE:
 			default:
--- kdenetwork-4.6.0/kopete/libkopete/avdevice/videodevice.h	2011-01-20 00:20:41.000000000 +0200
+++ kdenetwork-4.6.0/kopete/libkopete/avdevice/videodevice.h	2011-02-09 23:52:20.000000000 +0200
@@ -55,7 +55,7 @@
 #include <linux/fs.h>
 #include <linux/kernel.h>
 #endif
-#include <linux/videodev.h>
+#include <linux/videodev2.h>
 #define VIDEO_MODE_PAL_Nc  3
 #define VIDEO_MODE_PAL_M   4
 #define VIDEO_MODE_PAL_N   5
@@ -86,8 +86,6 @@
 {
 	VIDEODEV_DRIVER_NONE
 #if (defined(__linux__) || defined(__FreeBSD__)) && defined(ENABLE_AV)
-        ,
-	VIDEODEV_DRIVER_V4L
 #ifdef V4L2_CAP_VIDEO_CAPTURE
         ,
 	VIDEODEV_DRIVER_V4L2
@@ -367,8 +365,6 @@
 	struct v4l2_format fmt;
 //	struct v4l2_input m_input;
 #endif
-	struct video_capability V4L_capabilities;
-	struct video_buffer V4L_videobuffer;
 #endif	
 	int currentwidth, minwidth, maxwidth, currentheight, minheight, maxheight;
 
