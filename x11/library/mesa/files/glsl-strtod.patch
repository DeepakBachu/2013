From 90cb5861819f860e98ec4e0f59b6aa1d4d95adee Mon Sep 17 00:00:00 2001
From: Brian Paul <brianp@vmware.com>
Date: Mon, 13 Dec 2010 08:41:08 -0700
Subject: [PATCH] glsl: new glsl_strtod() wrapper to fix decimal point interpretation

We always want to use '.' as the decimal point.

See http://bugs.freedesktop.org/show_bug.cgi?id=24531
---
 src/glsl/Makefile         |    1 +
 src/glsl/SConscript       |    1 +
 src/glsl/glsl_lexer.cpp   |  443 ++++++++++++++++++++++-----------------------
 src/glsl/glsl_lexer.lpp   |   11 +-
 src/glsl/s_expression.cpp |    2 +-
 src/glsl/s_expression.h   |    1 +
 src/glsl/strtod.c         |   56 ++++++
 src/glsl/strtod.h         |   43 +++++
 8 files changed, 329 insertions(+), 229 deletions(-)
 create mode 100644 src/glsl/strtod.c
 create mode 100644 src/glsl/strtod.h

Index: mesa-7.9_20101018/src/glsl/Makefile
===================================================================
--- mesa-7.9_20101018.orig/src/glsl/Makefile
+++ mesa-7.9_20101018/src/glsl/Makefile
@@ -16,6 +16,7 @@ GLCPP_SOURCES = \
 	glcpp/glcpp.c
 
 C_SOURCES = \
+	strtod.c \
 	$(LIBGLCPP_SOURCES)
 
 CXX_SOURCES = \
Index: mesa-7.9_20101018/src/glsl/SConscript
===================================================================
--- mesa-7.9_20101018.orig/src/glsl/SConscript
+++ mesa-7.9_20101018/src/glsl/SConscript
@@ -76,6 +76,7 @@ sources = [
     'lower_variable_index_to_cond_assign.cpp',
     'opt_redundant_jumps.cpp',
     's_expression.cpp',
+    'strtod.c',
 ]
 
 glsl = env.ConvenienceLibrary(
Index: mesa-7.9_20101018/src/glsl/glsl_lexer.cpp
===================================================================
--- mesa-7.9_20101018.orig/src/glsl/glsl_lexer.cpp
+++ mesa-7.9_20101018/src/glsl/glsl_lexer.cpp
@@ -941,6 +941,7 @@ static yyconst flex_int16_t yy_chk[1145]
  * DEALINGS IN THE SOFTWARE.
  */
 #include <ctype.h>
+#include "strtod.h"
 #include "ast.h"
 #include "glsl_parser_extras.h"
 #include "glsl_parser.h"
@@ -986,7 +987,7 @@ static yyconst flex_int16_t yy_chk[1145]
       }									\
    } while (0)
 
-#line 990 "glsl_lexer.cpp"
+#line 991 "glsl_lexer.cpp"
 
 #define INITIAL 0
 #define PP 1
@@ -1121,7 +1122,7 @@ static int input (yyscan_t yyscanner );
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
  */
-#define ECHO fwrite( yytext, yyleng, 1, yyout )
+#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
 #endif
 
 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -1133,7 +1134,7 @@ static int input (yyscan_t yyscanner );
 		{ \
 		int c = '*'; \
 		int n; \
-		for ( n = 0; n < max_size && \
+		for ( n = 0; n < (size_t) max_size && \
 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
 			buf[n] = (char) c; \
 		if ( c == '\n' ) \
@@ -1220,10 +1221,10 @@ YY_DECL
 	register int yy_act;
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 
-#line 86 "glsl_lexer.lpp"
+#line 87 "glsl_lexer.lpp"
 
 
-#line 1227 "glsl_lexer.cpp"
+#line 1228 "glsl_lexer.cpp"
 
     yylval = yylval_param;
 
@@ -1309,7 +1310,7 @@ do_action:	/* This label is used only to
 
 case 1:
 YY_RULE_SETUP
-#line 88 "glsl_lexer.lpp"
+#line 89 "glsl_lexer.lpp"
 ;
 	YY_BREAK
 /* Preprocessor tokens. */ 
@@ -1318,17 +1319,17 @@ case 2:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 91 "glsl_lexer.lpp"
+#line 92 "glsl_lexer.lpp"
 ;
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 92 "glsl_lexer.lpp"
+#line 93 "glsl_lexer.lpp"
 { BEGIN PP; return VERSION; }
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 93 "glsl_lexer.lpp"
+#line 94 "glsl_lexer.lpp"
 { BEGIN PP; return EXTENSION; }
 	YY_BREAK
 case 5:
@@ -1336,7 +1337,7 @@ case 5:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 94 "glsl_lexer.lpp"
+#line 95 "glsl_lexer.lpp"
 {
 				   /* Eat characters until the first digit is
 				    * encountered
@@ -1358,7 +1359,7 @@ case 6:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 109 "glsl_lexer.lpp"
+#line 110 "glsl_lexer.lpp"
 {
 				   /* Eat characters until the first digit is
 				    * encountered
@@ -1376,7 +1377,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 123 "glsl_lexer.lpp"
+#line 124 "glsl_lexer.lpp"
 {
 				  BEGIN PP;
 				  return PRAGMA_DEBUG_ON;
@@ -1384,7 +1385,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 127 "glsl_lexer.lpp"
+#line 128 "glsl_lexer.lpp"
 {
 				  BEGIN PP;
 				  return PRAGMA_DEBUG_OFF;
@@ -1392,7 +1393,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 131 "glsl_lexer.lpp"
+#line 132 "glsl_lexer.lpp"
 {
 				  BEGIN PP;
 				  return PRAGMA_OPTIMIZE_ON;
@@ -1400,7 +1401,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 135 "glsl_lexer.lpp"
+#line 136 "glsl_lexer.lpp"
 {
 				  BEGIN PP;
 				  return PRAGMA_OPTIMIZE_OFF;
@@ -1408,38 +1409,38 @@ YY_RULE_SETUP
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 139 "glsl_lexer.lpp"
+#line 140 "glsl_lexer.lpp"
 { BEGIN PRAGMA; }
 	YY_BREAK
 case 12:
 /* rule 12 can match eol */
 YY_RULE_SETUP
-#line 141 "glsl_lexer.lpp"
+#line 142 "glsl_lexer.lpp"
 { BEGIN 0; yylineno++; yycolumn = 0; }
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 142 "glsl_lexer.lpp"
+#line 143 "glsl_lexer.lpp"
 { }
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 144 "glsl_lexer.lpp"
+#line 145 "glsl_lexer.lpp"
 { }
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 145 "glsl_lexer.lpp"
+#line 146 "glsl_lexer.lpp"
 { }
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 146 "glsl_lexer.lpp"
+#line 147 "glsl_lexer.lpp"
 return COLON;
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 147 "glsl_lexer.lpp"
+#line 148 "glsl_lexer.lpp"
 {
 				   yylval->identifier = strdup(yytext);
 				   return IDENTIFIER;
@@ -1447,7 +1448,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 151 "glsl_lexer.lpp"
+#line 152 "glsl_lexer.lpp"
 {
 				    yylval->n = strtol(yytext, NULL, 10);
 				    return INTCONSTANT;
@@ -1456,283 +1457,283 @@ YY_RULE_SETUP
 case 19:
 /* rule 19 can match eol */
 YY_RULE_SETUP
-#line 155 "glsl_lexer.lpp"
+#line 156 "glsl_lexer.lpp"
 { BEGIN 0; yylineno++; yycolumn = 0; return EOL; }
 	YY_BREAK
 case 20:
 /* rule 20 can match eol */
 YY_RULE_SETUP
-#line 157 "glsl_lexer.lpp"
+#line 158 "glsl_lexer.lpp"
 { yylineno++; yycolumn = 0; }
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 159 "glsl_lexer.lpp"
+#line 160 "glsl_lexer.lpp"
 return ATTRIBUTE;
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 160 "glsl_lexer.lpp"
+#line 161 "glsl_lexer.lpp"
 return CONST_TOK;
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 161 "glsl_lexer.lpp"
+#line 162 "glsl_lexer.lpp"
 return BOOL_TOK;
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 162 "glsl_lexer.lpp"
+#line 163 "glsl_lexer.lpp"
 return FLOAT_TOK;
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 163 "glsl_lexer.lpp"
+#line 164 "glsl_lexer.lpp"
 return INT_TOK;
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 165 "glsl_lexer.lpp"
+#line 166 "glsl_lexer.lpp"
 return BREAK;
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 166 "glsl_lexer.lpp"
+#line 167 "glsl_lexer.lpp"
 return CONTINUE;
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 167 "glsl_lexer.lpp"
+#line 168 "glsl_lexer.lpp"
 return DO;
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 168 "glsl_lexer.lpp"
+#line 169 "glsl_lexer.lpp"
 return WHILE;
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 169 "glsl_lexer.lpp"
+#line 170 "glsl_lexer.lpp"
 return ELSE;
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 170 "glsl_lexer.lpp"
+#line 171 "glsl_lexer.lpp"
 return FOR;
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 171 "glsl_lexer.lpp"
+#line 172 "glsl_lexer.lpp"
 return IF;
 	YY_BREAK
 case 33:
 YY_RULE_SETUP
-#line 172 "glsl_lexer.lpp"
+#line 173 "glsl_lexer.lpp"
 return DISCARD;
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
-#line 173 "glsl_lexer.lpp"
+#line 174 "glsl_lexer.lpp"
 return RETURN;
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 175 "glsl_lexer.lpp"
+#line 176 "glsl_lexer.lpp"
 return BVEC2;
 	YY_BREAK
 case 36:
 YY_RULE_SETUP
-#line 176 "glsl_lexer.lpp"
+#line 177 "glsl_lexer.lpp"
 return BVEC3;
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
-#line 177 "glsl_lexer.lpp"
+#line 178 "glsl_lexer.lpp"
 return BVEC4;
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
-#line 178 "glsl_lexer.lpp"
+#line 179 "glsl_lexer.lpp"
 return IVEC2;
 	YY_BREAK
 case 39:
 YY_RULE_SETUP
-#line 179 "glsl_lexer.lpp"
+#line 180 "glsl_lexer.lpp"
 return IVEC3;
 	YY_BREAK
 case 40:
 YY_RULE_SETUP
-#line 180 "glsl_lexer.lpp"
+#line 181 "glsl_lexer.lpp"
 return IVEC4;
 	YY_BREAK
 case 41:
 YY_RULE_SETUP
-#line 181 "glsl_lexer.lpp"
+#line 182 "glsl_lexer.lpp"
 return VEC2;
 	YY_BREAK
 case 42:
 YY_RULE_SETUP
-#line 182 "glsl_lexer.lpp"
+#line 183 "glsl_lexer.lpp"
 return VEC3;
 	YY_BREAK
 case 43:
 YY_RULE_SETUP
-#line 183 "glsl_lexer.lpp"
+#line 184 "glsl_lexer.lpp"
 return VEC4;
 	YY_BREAK
 case 44:
 YY_RULE_SETUP
-#line 184 "glsl_lexer.lpp"
+#line 185 "glsl_lexer.lpp"
 return MAT2X2;
 	YY_BREAK
 case 45:
 YY_RULE_SETUP
-#line 185 "glsl_lexer.lpp"
+#line 186 "glsl_lexer.lpp"
 return MAT3X3;
 	YY_BREAK
 case 46:
 YY_RULE_SETUP
-#line 186 "glsl_lexer.lpp"
+#line 187 "glsl_lexer.lpp"
 return MAT4X4;
 	YY_BREAK
 case 47:
 YY_RULE_SETUP
-#line 187 "glsl_lexer.lpp"
+#line 188 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(120, MAT2X2);
 	YY_BREAK
 case 48:
 YY_RULE_SETUP
-#line 188 "glsl_lexer.lpp"
+#line 189 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(120, MAT2X3);
 	YY_BREAK
 case 49:
 YY_RULE_SETUP
-#line 189 "glsl_lexer.lpp"
+#line 190 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(120, MAT2X4);
 	YY_BREAK
 case 50:
 YY_RULE_SETUP
-#line 190 "glsl_lexer.lpp"
+#line 191 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(120, MAT3X2);
 	YY_BREAK
 case 51:
 YY_RULE_SETUP
-#line 191 "glsl_lexer.lpp"
+#line 192 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(120, MAT3X3);
 	YY_BREAK
 case 52:
 YY_RULE_SETUP
-#line 192 "glsl_lexer.lpp"
+#line 193 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(120, MAT3X4);
 	YY_BREAK
 case 53:
 YY_RULE_SETUP
-#line 193 "glsl_lexer.lpp"
+#line 194 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(120, MAT4X2);
 	YY_BREAK
 case 54:
 YY_RULE_SETUP
-#line 194 "glsl_lexer.lpp"
+#line 195 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(120, MAT4X3);
 	YY_BREAK
 case 55:
 YY_RULE_SETUP
-#line 195 "glsl_lexer.lpp"
+#line 196 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(120, MAT4X4);
 	YY_BREAK
 case 56:
 YY_RULE_SETUP
-#line 197 "glsl_lexer.lpp"
+#line 198 "glsl_lexer.lpp"
 return IN_TOK;
 	YY_BREAK
 case 57:
 YY_RULE_SETUP
-#line 198 "glsl_lexer.lpp"
+#line 199 "glsl_lexer.lpp"
 return OUT_TOK;
 	YY_BREAK
 case 58:
 YY_RULE_SETUP
-#line 199 "glsl_lexer.lpp"
+#line 200 "glsl_lexer.lpp"
 return INOUT_TOK;
 	YY_BREAK
 case 59:
 YY_RULE_SETUP
-#line 200 "glsl_lexer.lpp"
+#line 201 "glsl_lexer.lpp"
 return UNIFORM;
 	YY_BREAK
 case 60:
 YY_RULE_SETUP
-#line 201 "glsl_lexer.lpp"
+#line 202 "glsl_lexer.lpp"
 return VARYING;
 	YY_BREAK
 case 61:
 YY_RULE_SETUP
-#line 202 "glsl_lexer.lpp"
+#line 203 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(120, CENTROID);
 	YY_BREAK
 case 62:
 YY_RULE_SETUP
-#line 203 "glsl_lexer.lpp"
+#line 204 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER_ES(120, INVARIANT);
 	YY_BREAK
 case 63:
 YY_RULE_SETUP
-#line 205 "glsl_lexer.lpp"
+#line 206 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER_ES(130, FLAT);
 	YY_BREAK
 case 64:
 YY_RULE_SETUP
-#line 206 "glsl_lexer.lpp"
+#line 207 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, SMOOTH);
 	YY_BREAK
 case 65:
 YY_RULE_SETUP
-#line 207 "glsl_lexer.lpp"
+#line 208 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, NOPERSPECTIVE);
 	YY_BREAK
 case 66:
 YY_RULE_SETUP
-#line 209 "glsl_lexer.lpp"
+#line 210 "glsl_lexer.lpp"
 return SAMPLER1D;
 	YY_BREAK
 case 67:
 YY_RULE_SETUP
-#line 210 "glsl_lexer.lpp"
+#line 211 "glsl_lexer.lpp"
 return SAMPLER2D;
 	YY_BREAK
 case 68:
 YY_RULE_SETUP
-#line 211 "glsl_lexer.lpp"
+#line 212 "glsl_lexer.lpp"
 return SAMPLER3D;
 	YY_BREAK
 case 69:
 YY_RULE_SETUP
-#line 212 "glsl_lexer.lpp"
+#line 213 "glsl_lexer.lpp"
 return SAMPLERCUBE;
 	YY_BREAK
 case 70:
 YY_RULE_SETUP
-#line 213 "glsl_lexer.lpp"
+#line 214 "glsl_lexer.lpp"
 return SAMPLER1DSHADOW;
 	YY_BREAK
 case 71:
 YY_RULE_SETUP
-#line 214 "glsl_lexer.lpp"
+#line 215 "glsl_lexer.lpp"
 return SAMPLER2DSHADOW;
 	YY_BREAK
 case 72:
 YY_RULE_SETUP
-#line 216 "glsl_lexer.lpp"
+#line 217 "glsl_lexer.lpp"
 return STRUCT;
 	YY_BREAK
 case 73:
 YY_RULE_SETUP
-#line 217 "glsl_lexer.lpp"
+#line 218 "glsl_lexer.lpp"
 return VOID_TOK;
 	YY_BREAK
 case 74:
 YY_RULE_SETUP
-#line 219 "glsl_lexer.lpp"
+#line 220 "glsl_lexer.lpp"
 {
 		  if ((yyextra->language_version >= 140)
 		      || (yyextra->ARB_fragment_coord_conventions_enable)){
@@ -1745,102 +1746,102 @@ YY_RULE_SETUP
 	YY_BREAK
 case 75:
 YY_RULE_SETUP
-#line 229 "glsl_lexer.lpp"
+#line 230 "glsl_lexer.lpp"
 return INC_OP;
 	YY_BREAK
 case 76:
 YY_RULE_SETUP
-#line 230 "glsl_lexer.lpp"
+#line 231 "glsl_lexer.lpp"
 return DEC_OP;
 	YY_BREAK
 case 77:
 YY_RULE_SETUP
-#line 231 "glsl_lexer.lpp"
+#line 232 "glsl_lexer.lpp"
 return LE_OP;
 	YY_BREAK
 case 78:
 YY_RULE_SETUP
-#line 232 "glsl_lexer.lpp"
+#line 233 "glsl_lexer.lpp"
 return GE_OP;
 	YY_BREAK
 case 79:
 YY_RULE_SETUP
-#line 233 "glsl_lexer.lpp"
+#line 234 "glsl_lexer.lpp"
 return EQ_OP;
 	YY_BREAK
 case 80:
 YY_RULE_SETUP
-#line 234 "glsl_lexer.lpp"
+#line 235 "glsl_lexer.lpp"
 return NE_OP;
 	YY_BREAK
 case 81:
 YY_RULE_SETUP
-#line 235 "glsl_lexer.lpp"
+#line 236 "glsl_lexer.lpp"
 return AND_OP;
 	YY_BREAK
 case 82:
 YY_RULE_SETUP
-#line 236 "glsl_lexer.lpp"
+#line 237 "glsl_lexer.lpp"
 return OR_OP;
 	YY_BREAK
 case 83:
 YY_RULE_SETUP
-#line 237 "glsl_lexer.lpp"
+#line 238 "glsl_lexer.lpp"
 return XOR_OP;
 	YY_BREAK
 case 84:
 YY_RULE_SETUP
-#line 239 "glsl_lexer.lpp"
+#line 240 "glsl_lexer.lpp"
 return MUL_ASSIGN;
 	YY_BREAK
 case 85:
 YY_RULE_SETUP
-#line 240 "glsl_lexer.lpp"
+#line 241 "glsl_lexer.lpp"
 return DIV_ASSIGN;
 	YY_BREAK
 case 86:
 YY_RULE_SETUP
-#line 241 "glsl_lexer.lpp"
+#line 242 "glsl_lexer.lpp"
 return ADD_ASSIGN;
 	YY_BREAK
 case 87:
 YY_RULE_SETUP
-#line 242 "glsl_lexer.lpp"
+#line 243 "glsl_lexer.lpp"
 return MOD_ASSIGN;
 	YY_BREAK
 case 88:
 YY_RULE_SETUP
-#line 243 "glsl_lexer.lpp"
+#line 244 "glsl_lexer.lpp"
 return LEFT_ASSIGN;
 	YY_BREAK
 case 89:
 YY_RULE_SETUP
-#line 244 "glsl_lexer.lpp"
+#line 245 "glsl_lexer.lpp"
 return RIGHT_ASSIGN;
 	YY_BREAK
 case 90:
 YY_RULE_SETUP
-#line 245 "glsl_lexer.lpp"
+#line 246 "glsl_lexer.lpp"
 return AND_ASSIGN;
 	YY_BREAK
 case 91:
 YY_RULE_SETUP
-#line 246 "glsl_lexer.lpp"
+#line 247 "glsl_lexer.lpp"
 return XOR_ASSIGN;
 	YY_BREAK
 case 92:
 YY_RULE_SETUP
-#line 247 "glsl_lexer.lpp"
+#line 248 "glsl_lexer.lpp"
 return OR_ASSIGN;
 	YY_BREAK
 case 93:
 YY_RULE_SETUP
-#line 248 "glsl_lexer.lpp"
+#line 249 "glsl_lexer.lpp"
 return SUB_ASSIGN;
 	YY_BREAK
 case 94:
 YY_RULE_SETUP
-#line 250 "glsl_lexer.lpp"
+#line 251 "glsl_lexer.lpp"
 {
 			    yylval->n = strtol(yytext, NULL, 10);
 			    return INTCONSTANT;
@@ -1848,7 +1849,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 95:
 YY_RULE_SETUP
-#line 254 "glsl_lexer.lpp"
+#line 255 "glsl_lexer.lpp"
 {
 			    yylval->n = strtol(yytext + 2, NULL, 16);
 			    return INTCONSTANT;
@@ -1856,7 +1857,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 96:
 YY_RULE_SETUP
-#line 258 "glsl_lexer.lpp"
+#line 259 "glsl_lexer.lpp"
 {
 			    yylval->n = strtol(yytext, NULL, 8);
 			    return INTCONSTANT;
@@ -1864,47 +1865,47 @@ YY_RULE_SETUP
 	YY_BREAK
 case 97:
 YY_RULE_SETUP
-#line 263 "glsl_lexer.lpp"
+#line 264 "glsl_lexer.lpp"
 {
-			    yylval->real = strtod(yytext, NULL);
+			    yylval->real = glsl_strtod(yytext, NULL);
 			    return FLOATCONSTANT;
 			}
 	YY_BREAK
 case 98:
 YY_RULE_SETUP
-#line 267 "glsl_lexer.lpp"
+#line 268 "glsl_lexer.lpp"
 {
-			    yylval->real = strtod(yytext, NULL);
+			    yylval->real = glsl_strtod(yytext, NULL);
 			    return FLOATCONSTANT;
 			}
 	YY_BREAK
 case 99:
 YY_RULE_SETUP
-#line 271 "glsl_lexer.lpp"
+#line 272 "glsl_lexer.lpp"
 {
-			    yylval->real = strtod(yytext, NULL);
+			    yylval->real = glsl_strtod(yytext, NULL);
 			    return FLOATCONSTANT;
 			}
 	YY_BREAK
 case 100:
 YY_RULE_SETUP
-#line 275 "glsl_lexer.lpp"
+#line 276 "glsl_lexer.lpp"
 {
-			    yylval->real = strtod(yytext, NULL);
+			    yylval->real = glsl_strtod(yytext, NULL);
 			    return FLOATCONSTANT;
 			}
 	YY_BREAK
 case 101:
 YY_RULE_SETUP
-#line 279 "glsl_lexer.lpp"
+#line 280 "glsl_lexer.lpp"
 {
-			    yylval->real = strtod(yytext, NULL);
+			    yylval->real = glsl_strtod(yytext, NULL);
 			    return FLOATCONSTANT;
 			}
 	YY_BREAK
 case 102:
 YY_RULE_SETUP
-#line 284 "glsl_lexer.lpp"
+#line 285 "glsl_lexer.lpp"
 {
 			    yylval->n = 1;
 			    return BOOLCONSTANT;
@@ -1912,7 +1913,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 103:
 YY_RULE_SETUP
-#line 288 "glsl_lexer.lpp"
+#line 289 "glsl_lexer.lpp"
 {
 			    yylval->n = 0;
 			    return BOOLCONSTANT;
@@ -1921,394 +1922,394 @@ YY_RULE_SETUP
 /* Reserved words in GLSL 1.10. */
 case 104:
 YY_RULE_SETUP
-#line 295 "glsl_lexer.lpp"
+#line 296 "glsl_lexer.lpp"
 RESERVED_WORD(999, ASM);
 	YY_BREAK
 case 105:
 YY_RULE_SETUP
-#line 296 "glsl_lexer.lpp"
+#line 297 "glsl_lexer.lpp"
 RESERVED_WORD(999, CLASS);
 	YY_BREAK
 case 106:
 YY_RULE_SETUP
-#line 297 "glsl_lexer.lpp"
+#line 298 "glsl_lexer.lpp"
 RESERVED_WORD(999, UNION);
 	YY_BREAK
 case 107:
 YY_RULE_SETUP
-#line 298 "glsl_lexer.lpp"
+#line 299 "glsl_lexer.lpp"
 RESERVED_WORD(999, ENUM);
 	YY_BREAK
 case 108:
 YY_RULE_SETUP
-#line 299 "glsl_lexer.lpp"
+#line 300 "glsl_lexer.lpp"
 RESERVED_WORD(999, TYPEDEF);
 	YY_BREAK
 case 109:
 YY_RULE_SETUP
-#line 300 "glsl_lexer.lpp"
+#line 301 "glsl_lexer.lpp"
 RESERVED_WORD(999, TEMPLATE);
 	YY_BREAK
 case 110:
 YY_RULE_SETUP
-#line 301 "glsl_lexer.lpp"
+#line 302 "glsl_lexer.lpp"
 RESERVED_WORD(999, THIS);
 	YY_BREAK
 case 111:
 YY_RULE_SETUP
-#line 302 "glsl_lexer.lpp"
+#line 303 "glsl_lexer.lpp"
 RESERVED_WORD(999, PACKED_TOK);
 	YY_BREAK
 case 112:
 YY_RULE_SETUP
-#line 303 "glsl_lexer.lpp"
+#line 304 "glsl_lexer.lpp"
 RESERVED_WORD(999, GOTO);
 	YY_BREAK
 case 113:
 YY_RULE_SETUP
-#line 304 "glsl_lexer.lpp"
+#line 305 "glsl_lexer.lpp"
 RESERVED_WORD(130, SWITCH);
 	YY_BREAK
 case 114:
 YY_RULE_SETUP
-#line 305 "glsl_lexer.lpp"
+#line 306 "glsl_lexer.lpp"
 RESERVED_WORD(130, DEFAULT);
 	YY_BREAK
 case 115:
 YY_RULE_SETUP
-#line 306 "glsl_lexer.lpp"
+#line 307 "glsl_lexer.lpp"
 RESERVED_WORD(999, INLINE_TOK);
 	YY_BREAK
 case 116:
 YY_RULE_SETUP
-#line 307 "glsl_lexer.lpp"
+#line 308 "glsl_lexer.lpp"
 RESERVED_WORD(999, NOINLINE);
 	YY_BREAK
 case 117:
 YY_RULE_SETUP
-#line 308 "glsl_lexer.lpp"
+#line 309 "glsl_lexer.lpp"
 RESERVED_WORD(999, VOLATILE);
 	YY_BREAK
 case 118:
 YY_RULE_SETUP
-#line 309 "glsl_lexer.lpp"
+#line 310 "glsl_lexer.lpp"
 RESERVED_WORD(999, PUBLIC_TOK);
 	YY_BREAK
 case 119:
 YY_RULE_SETUP
-#line 310 "glsl_lexer.lpp"
+#line 311 "glsl_lexer.lpp"
 RESERVED_WORD(999, STATIC);
 	YY_BREAK
 case 120:
 YY_RULE_SETUP
-#line 311 "glsl_lexer.lpp"
+#line 312 "glsl_lexer.lpp"
 RESERVED_WORD(999, EXTERN);
 	YY_BREAK
 case 121:
 YY_RULE_SETUP
-#line 312 "glsl_lexer.lpp"
+#line 313 "glsl_lexer.lpp"
 RESERVED_WORD(999, EXTERNAL);
 	YY_BREAK
 case 122:
 YY_RULE_SETUP
-#line 313 "glsl_lexer.lpp"
+#line 314 "glsl_lexer.lpp"
 RESERVED_WORD(999, INTERFACE);
 	YY_BREAK
 case 123:
 YY_RULE_SETUP
-#line 314 "glsl_lexer.lpp"
+#line 315 "glsl_lexer.lpp"
 RESERVED_WORD(999, LONG_TOK);
 	YY_BREAK
 case 124:
 YY_RULE_SETUP
-#line 315 "glsl_lexer.lpp"
+#line 316 "glsl_lexer.lpp"
 RESERVED_WORD(999, SHORT_TOK);
 	YY_BREAK
 case 125:
 YY_RULE_SETUP
-#line 316 "glsl_lexer.lpp"
+#line 317 "glsl_lexer.lpp"
 RESERVED_WORD(999, DOUBLE_TOK);
 	YY_BREAK
 case 126:
 YY_RULE_SETUP
-#line 317 "glsl_lexer.lpp"
+#line 318 "glsl_lexer.lpp"
 RESERVED_WORD(999, HALF);
 	YY_BREAK
 case 127:
 YY_RULE_SETUP
-#line 318 "glsl_lexer.lpp"
+#line 319 "glsl_lexer.lpp"
 RESERVED_WORD(999, FIXED_TOK);
 	YY_BREAK
 case 128:
 YY_RULE_SETUP
-#line 319 "glsl_lexer.lpp"
+#line 320 "glsl_lexer.lpp"
 RESERVED_WORD(999, UNSIGNED);
 	YY_BREAK
 case 129:
 YY_RULE_SETUP
-#line 320 "glsl_lexer.lpp"
+#line 321 "glsl_lexer.lpp"
 RESERVED_WORD(999, INPUT_TOK);
 	YY_BREAK
 case 130:
 YY_RULE_SETUP
-#line 321 "glsl_lexer.lpp"
+#line 322 "glsl_lexer.lpp"
 RESERVED_WORD(999, OUTPUT);
 	YY_BREAK
 case 131:
 YY_RULE_SETUP
-#line 322 "glsl_lexer.lpp"
+#line 323 "glsl_lexer.lpp"
 RESERVED_WORD(999, HVEC2);
 	YY_BREAK
 case 132:
 YY_RULE_SETUP
-#line 323 "glsl_lexer.lpp"
+#line 324 "glsl_lexer.lpp"
 RESERVED_WORD(999, HVEC3);
 	YY_BREAK
 case 133:
 YY_RULE_SETUP
-#line 324 "glsl_lexer.lpp"
+#line 325 "glsl_lexer.lpp"
 RESERVED_WORD(999, HVEC4);
 	YY_BREAK
 case 134:
 YY_RULE_SETUP
-#line 325 "glsl_lexer.lpp"
+#line 326 "glsl_lexer.lpp"
 RESERVED_WORD(999, DVEC2);
 	YY_BREAK
 case 135:
 YY_RULE_SETUP
-#line 326 "glsl_lexer.lpp"
+#line 327 "glsl_lexer.lpp"
 RESERVED_WORD(999, DVEC3);
 	YY_BREAK
 case 136:
 YY_RULE_SETUP
-#line 327 "glsl_lexer.lpp"
+#line 328 "glsl_lexer.lpp"
 RESERVED_WORD(999, DVEC4);
 	YY_BREAK
 case 137:
 YY_RULE_SETUP
-#line 328 "glsl_lexer.lpp"
+#line 329 "glsl_lexer.lpp"
 RESERVED_WORD(999, FVEC2);
 	YY_BREAK
 case 138:
 YY_RULE_SETUP
-#line 329 "glsl_lexer.lpp"
+#line 330 "glsl_lexer.lpp"
 RESERVED_WORD(999, FVEC3);
 	YY_BREAK
 case 139:
 YY_RULE_SETUP
-#line 330 "glsl_lexer.lpp"
+#line 331 "glsl_lexer.lpp"
 RESERVED_WORD(999, FVEC4);
 	YY_BREAK
 case 140:
 YY_RULE_SETUP
-#line 331 "glsl_lexer.lpp"
+#line 332 "glsl_lexer.lpp"
 return SAMPLER2DRECT;
 	YY_BREAK
 case 141:
 YY_RULE_SETUP
-#line 332 "glsl_lexer.lpp"
+#line 333 "glsl_lexer.lpp"
 RESERVED_WORD(999, SAMPLER3DRECT);
 	YY_BREAK
 case 142:
 YY_RULE_SETUP
-#line 333 "glsl_lexer.lpp"
+#line 334 "glsl_lexer.lpp"
 return SAMPLER2DRECTSHADOW;
 	YY_BREAK
 case 143:
 YY_RULE_SETUP
-#line 334 "glsl_lexer.lpp"
+#line 335 "glsl_lexer.lpp"
 RESERVED_WORD(999, SIZEOF);
 	YY_BREAK
 case 144:
 YY_RULE_SETUP
-#line 335 "glsl_lexer.lpp"
+#line 336 "glsl_lexer.lpp"
 RESERVED_WORD(999, CAST);
 	YY_BREAK
 case 145:
 YY_RULE_SETUP
-#line 336 "glsl_lexer.lpp"
+#line 337 "glsl_lexer.lpp"
 RESERVED_WORD(999, NAMESPACE);
 	YY_BREAK
 case 146:
 YY_RULE_SETUP
-#line 337 "glsl_lexer.lpp"
+#line 338 "glsl_lexer.lpp"
 RESERVED_WORD(999, USING);
 	YY_BREAK
 /* Additional reserved words in GLSL 1.20. */
 case 147:
 YY_RULE_SETUP
-#line 340 "glsl_lexer.lpp"
+#line 341 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER_ES(120, LOWP);
 	YY_BREAK
 case 148:
 YY_RULE_SETUP
-#line 341 "glsl_lexer.lpp"
+#line 342 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER_ES(120, MEDIUMP);
 	YY_BREAK
 case 149:
 YY_RULE_SETUP
-#line 342 "glsl_lexer.lpp"
+#line 343 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER_ES(120, HIGHP);
 	YY_BREAK
 case 150:
 YY_RULE_SETUP
-#line 343 "glsl_lexer.lpp"
+#line 344 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER_ES(120, PRECISION);
 	YY_BREAK
 /* Additional reserved words in GLSL 1.30. */
 case 151:
 YY_RULE_SETUP
-#line 346 "glsl_lexer.lpp"
+#line 347 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, COMMON);
 	YY_BREAK
 case 152:
 YY_RULE_SETUP
-#line 347 "glsl_lexer.lpp"
+#line 348 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, PARTITION);
 	YY_BREAK
 case 153:
 YY_RULE_SETUP
-#line 348 "glsl_lexer.lpp"
+#line 349 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, ACTIVE);
 	YY_BREAK
 case 154:
 YY_RULE_SETUP
-#line 349 "glsl_lexer.lpp"
+#line 350 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER_ES(130, SUPERP);
 	YY_BREAK
 case 155:
 YY_RULE_SETUP
-#line 350 "glsl_lexer.lpp"
+#line 351 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, SAMPLERBUFFER);
 	YY_BREAK
 case 156:
 YY_RULE_SETUP
-#line 351 "glsl_lexer.lpp"
+#line 352 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, FILTER);
 	YY_BREAK
 case 157:
 YY_RULE_SETUP
-#line 352 "glsl_lexer.lpp"
+#line 353 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, IMAGE1D);
 	YY_BREAK
 case 158:
 YY_RULE_SETUP
-#line 353 "glsl_lexer.lpp"
+#line 354 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, IMAGE2D);
 	YY_BREAK
 case 159:
 YY_RULE_SETUP
-#line 354 "glsl_lexer.lpp"
+#line 355 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, IMAGE3D);
 	YY_BREAK
 case 160:
 YY_RULE_SETUP
-#line 355 "glsl_lexer.lpp"
+#line 356 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, IMAGECUBE);
 	YY_BREAK
 case 161:
 YY_RULE_SETUP
-#line 356 "glsl_lexer.lpp"
+#line 357 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, IIMAGE1D);
 	YY_BREAK
 case 162:
 YY_RULE_SETUP
-#line 357 "glsl_lexer.lpp"
+#line 358 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, IIMAGE2D);
 	YY_BREAK
 case 163:
 YY_RULE_SETUP
-#line 358 "glsl_lexer.lpp"
+#line 359 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, IIMAGE3D);
 	YY_BREAK
 case 164:
 YY_RULE_SETUP
-#line 359 "glsl_lexer.lpp"
+#line 360 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, IIMAGECUBE);
 	YY_BREAK
 case 165:
 YY_RULE_SETUP
-#line 360 "glsl_lexer.lpp"
+#line 361 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, UIMAGE1D);
 	YY_BREAK
 case 166:
 YY_RULE_SETUP
-#line 361 "glsl_lexer.lpp"
+#line 362 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, UIMAGE2D);
 	YY_BREAK
 case 167:
 YY_RULE_SETUP
-#line 362 "glsl_lexer.lpp"
+#line 363 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, UIMAGE3D);
 	YY_BREAK
 case 168:
 YY_RULE_SETUP
-#line 363 "glsl_lexer.lpp"
+#line 364 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, UIMAGECUBE);
 	YY_BREAK
 case 169:
 YY_RULE_SETUP
-#line 364 "glsl_lexer.lpp"
+#line 365 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, IMAGE1DARRAY);
 	YY_BREAK
 case 170:
 YY_RULE_SETUP
-#line 365 "glsl_lexer.lpp"
+#line 366 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, IMAGE2DARRAY);
 	YY_BREAK
 case 171:
 YY_RULE_SETUP
-#line 366 "glsl_lexer.lpp"
+#line 367 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, IIMAGE1DARRAY);
 	YY_BREAK
 case 172:
 YY_RULE_SETUP
-#line 367 "glsl_lexer.lpp"
+#line 368 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, IIMAGE2DARRAY);
 	YY_BREAK
 case 173:
 YY_RULE_SETUP
-#line 368 "glsl_lexer.lpp"
+#line 369 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, UIMAGE1DARRAY);
 	YY_BREAK
 case 174:
 YY_RULE_SETUP
-#line 369 "glsl_lexer.lpp"
+#line 370 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, UIMAGE2DARRAY);
 	YY_BREAK
 case 175:
 YY_RULE_SETUP
-#line 370 "glsl_lexer.lpp"
+#line 371 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, IMAGE1DSHADOW);
 	YY_BREAK
 case 176:
 YY_RULE_SETUP
-#line 371 "glsl_lexer.lpp"
+#line 372 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, IMAGE2DSHADOW);
 	YY_BREAK
 case 177:
 YY_RULE_SETUP
-#line 372 "glsl_lexer.lpp"
+#line 373 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, IMAGEBUFFER);
 	YY_BREAK
 case 178:
 YY_RULE_SETUP
-#line 373 "glsl_lexer.lpp"
+#line 374 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, IIMAGEBUFFER);
 	YY_BREAK
 case 179:
 YY_RULE_SETUP
-#line 374 "glsl_lexer.lpp"
+#line 375 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, UIMAGEBUFFER);
 	YY_BREAK
 case 180:
 YY_RULE_SETUP
-#line 375 "glsl_lexer.lpp"
+#line 376 "glsl_lexer.lpp"
 TOKEN_OR_IDENTIFIER(130, ROW_MAJOR);
 	YY_BREAK
 case 181:
 YY_RULE_SETUP
-#line 377 "glsl_lexer.lpp"
+#line 378 "glsl_lexer.lpp"
 {
 			    struct _mesa_glsl_parse_state *state = yyextra;
 			    void *ctx = state;	
@@ -2318,15 +2319,15 @@ YY_RULE_SETUP
 	YY_BREAK
 case 182:
 YY_RULE_SETUP
-#line 384 "glsl_lexer.lpp"
+#line 385 "glsl_lexer.lpp"
 { return yytext[0]; }
 	YY_BREAK
 case 183:
 YY_RULE_SETUP
-#line 386 "glsl_lexer.lpp"
+#line 387 "glsl_lexer.lpp"
 ECHO;
 	YY_BREAK
-#line 2330 "glsl_lexer.cpp"
+#line 2331 "glsl_lexer.cpp"
 case YY_STATE_EOF(INITIAL):
 case YY_STATE_EOF(PP):
 case YY_STATE_EOF(PRAGMA):
@@ -3469,7 +3470,7 @@ void _mesa_glsl_free (void * ptr , yysca
 
 #define YYTABLES_NAME "yytables"
 
-#line 386 "glsl_lexer.lpp"
+#line 387 "glsl_lexer.lpp"
 
 
 
Index: mesa-7.9_20101018/src/glsl/glsl_lexer.lpp
===================================================================
--- mesa-7.9_20101018.orig/src/glsl/glsl_lexer.lpp
+++ mesa-7.9_20101018/src/glsl/glsl_lexer.lpp
@@ -22,6 +22,7 @@
  * DEALINGS IN THE SOFTWARE.
  */
 #include <ctype.h>
+#include "strtod.h"
 #include "ast.h"
 #include "glsl_parser_extras.h"
 #include "glsl_parser.h"
@@ -261,23 +262,23 @@ layout		{
 			}
 
 [0-9]+\.[0-9]+([eE][+-]?[0-9]+)?[fF]?	{
-			    yylval->real = strtod(yytext, NULL);
+			    yylval->real = glsl_strtod(yytext, NULL);
 			    return FLOATCONSTANT;
 			}
 \.[0-9]+([eE][+-]?[0-9]+)?[fF]?		{
-			    yylval->real = strtod(yytext, NULL);
+			    yylval->real = glsl_strtod(yytext, NULL);
 			    return FLOATCONSTANT;
 			}
 [0-9]+\.([eE][+-]?[0-9]+)?[fF]?		{
-			    yylval->real = strtod(yytext, NULL);
+			    yylval->real = glsl_strtod(yytext, NULL);
 			    return FLOATCONSTANT;
 			}
 [0-9]+[eE][+-]?[0-9]+[fF]?		{
-			    yylval->real = strtod(yytext, NULL);
+			    yylval->real = glsl_strtod(yytext, NULL);
 			    return FLOATCONSTANT;
 			}
 [0-9]+[fF]		{
-			    yylval->real = strtod(yytext, NULL);
+			    yylval->real = glsl_strtod(yytext, NULL);
 			    return FLOATCONSTANT;
 			}
 
Index: mesa-7.9_20101018/src/glsl/s_expression.cpp
===================================================================
--- mesa-7.9_20101018.orig/src/glsl/s_expression.cpp
+++ mesa-7.9_20101018/src/glsl/s_expression.cpp
@@ -62,7 +62,7 @@ read_atom(void *ctx, const char *& src)
 
    // Check if the atom is a number.
    char *float_end = NULL;
-   double f = strtod(src, &float_end);
+   double f = glsl_strtod(src, &float_end);
    if (float_end != src) {
       char *int_end = NULL;
       int i = strtol(src, &int_end, 10);
Index: mesa-7.9_20101018/src/glsl/s_expression.h
===================================================================
--- mesa-7.9_20101018.orig/src/glsl/s_expression.h
+++ mesa-7.9_20101018/src/glsl/s_expression.h
@@ -26,6 +26,7 @@
 #ifndef S_EXPRESSION_H
 #define S_EXPRESSION_H
 
+#include "strtod.h"
 #include "list.h"
 
 #define SX_AS_(t,x) ((x) && ((s_expression*) x)->is_##t()) ? ((s_##t*) (x)) \
Index: mesa-7.9_20101018/src/glsl/strtod.c
===================================================================
--- /dev/null
+++ mesa-7.9_20101018/src/glsl/strtod.c
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2010 VMware, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+#include <stdlib.h>
+
+#ifdef _GNU_SOURCE
+#include <locale.h>
+#ifdef __APPLE__
+#include <xlocale.h>
+#endif
+#endif
+
+#include "strtod.h"
+
+
+
+/**
+ * Wrapper around strtod which uses the "C" locale so the decimal
+ * point is always '.'
+ */
+double
+glsl_strtod(const char *s, char **end)
+{
+#if defined(_GNU_SOURCE) && !defined(__CYGWIN__) && !defined(__FreeBSD__)
+   static locale_t loc = NULL;
+   if (!loc) {
+      loc = newlocale(LC_CTYPE_MASK, "C", NULL);
+   }
+   return strtod_l(s, end, loc);
+#else
+   return strtod(s, end);
+#endif
+}
Index: mesa-7.9_20101018/src/glsl/strtod.h
===================================================================
--- /dev/null
+++ mesa-7.9_20101018/src/glsl/strtod.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2010 VMware, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+#ifndef STRTOD_H
+#define STRTOD_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern double
+glsl_strtod(const char *s, char **end);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
